-- -*- mode: lua; coding: windows-1251-dos -*-

-- этот сквад будет назначаться создаваемым мобам
local SQUAD = 50


function attach( sm )
  sm:subscribe({ signal = "npc_use", fun = this.on_use })
  sm:subscribe({
      signal = "on_before_spawn_another_level",
      fun    = this.on_before_spawn_another_level
  })
  sm:subscribe({ signal = "on_monster_death",  fun = this.on_monster_death })
  sm:subscribe({ signal = "on_monster_net_destroy", fun = this.on_net_destroy })
  sm:subscribe({ signal = "on_monster_spawn",  fun = this.on_monster_spawn })
  sm:subscribe({ signal = "on_spawn", fun = this.on_spawn })
end


function subscribed( obj, binder )
  if not binder then binder = obj:binded_object() end
  if binder[ "battle.subscribed" ] then
    return true
  end
  return false
end


function subscribe( obj, binder, fast )
  if not binder then binder = obj:binded_object() end
  if not binder[ "battle.subscribed" ] then
    local s = {
      [ "signal" ] = "on_update",
      [ "self"   ] = obj,
      [ "fun"    ] = ( fast and this.cleanup_fast or this.cleanup ),
    }
    binder[ "battle.subscribed" ] = s
    ogse_signals.get_mgr():subscribe( s )
  end
end


function unsubscribe( obj, binder )
  if not binder then binder = obj:binded_object() end
  local subscribed = binder[ "battle.subscribed" ]
  if subscribed then
    ogse_signals.get_mgr():unsubscribe( subscribed )
    binder[ "battle.subscribed" ] = nil
  end
end


-- осмотрели мутанта и он больше не нужен, можно удалять "быстрым" уборщиком.
function on_use( obj )
  if obj:alive() or not obj:is_monster() then return end
  subscribe( obj )
end


function is_battle_spawned( obj )
  if not get_bool( obj:section(), "battle.spawned", true ) then
    return
  end
  local sobj = alife():object( obj:id() )
  if sobj then
    local ini = sobj:spawn_ini()
    return ini:section_exist( "battle" ) and ini or false
  end
  return false
end


local battle_monsters = {}
local volna_monsters  = {}

function on_monster_spawn( obj, binder )
  local ini = is_battle_spawned( obj )
  if ini then
    local volna = get_bool( "battle", "volna_goodwill", false, ini )
    if obj:alive() then
      battle_monsters[ obj:id() ] = true
      if volna then
        volna_monsters[ obj:id() ] = true
        obj:set_custom_panic_threshold( 0 )
        dsh_mob_home.create_home( obj, nil, 30, 50, true, false )
      end
    elseif volna and get_bool( "battle", "cleanup", true, ini ) then
      subscribe( obj, binder, volna )
    end
  end
end


function on_monster_death( obj, who )
  local binder = obj:binded_object()
  on_monster_spawn( obj, binder )
end


function on_net_destroy( obj )
  battle_monsters[ obj:id() ] = nil
  volna_monsters[ obj:id()  ] = nil
  unsubscribe( obj )
end


function add_deferred_battle( lvl, btl, wave )
  log2(
    "[%s]: add deferred battle on %s: %s, %s, %s",
    script_name(), level.name(), lvl, btl, wave
  )
  local var_name = "battle.deferred." .. lvl
  local deferred = ogse.load_var_safe( var_name ) or {}
  table.insert( deferred, { btl, wave } );
  ogse.save_var( var_name, deferred, "array_template", { "u8", "u8" } )
end


function restore_deferred_battles()
  local var_name = "battle.deferred." .. level.name()
  local deferred = ogse.load_var_safe( var_name )
  if not deferred then return end
  for i, b in ipairs( deferred ) do
    local btl, wave = unpack( b )
    log2(
      "[%s]: restore deferred battle on %s: %s, %s",
      script_name(), level.name(), btl, wave
    )
    battle_timer( 30 * i, level.name(), btl, wave )
  end
  ogse.delete_var( var_name )
end


function enemy_callback( obj, enemy, result )
  if not enemy:is_monster() then return end
  table.insert( result, false )
  return true
end


function on_before_spawn_another_level( lname, prev_lname, lc_sobj )
  if db.actor:has_info( "volna_goodwill" ) then
    ogse.save_var( "battle.volna_goodwill." .. prev_lname, true )
  end
  if ogse.load_var_safe( "battle.volna_goodwill." .. lname ) then
    db.actor:give_info_portion( "volna_goodwill" )
  else
    db.actor:disable_info_portion( "volna_goodwill" )
  end
  ogse.delete_var( "battle.volna_goodwill." .. lname )
end


local volna_enemy_callback

function set_enemy_callback()
  if not volna_enemy_callback then
    volna_enemy_callback = {
      signal = "on_monster_enemy_callback", fun = this.enemy_callback
    }
    ogse_signals.get_mgr():subscribe( volna_enemy_callback )
  end
end


function on_spawn()
  restore_deferred_battles()
  if db.actor:has_info( "volna_goodwill" ) then
    set_enemy_callback()
  end
end


function unset_enemy_callback()
  if volna_enemy_callback then
    ogse_signals.get_mgr():unsubscribe( volna_enemy_callback )
    volna_enemy_callback = nil
  end
end


class "battle_wave"
function battle_wave:__init( wave )
  for k, v in pairs( wave ) do
    self[ k ] = v
  end
end


function battle_wave:create_enemy( sect, pos, lv, gv )
  local sobj = dsh.create_free_mob( sect, pos, lv, gv )
  local sid  = get_string( sect, "battle.story_id" )
  if sid then
    alife():assign_story_id( sobj.id, story_ids[ sid ] )
  end
  sobj = alife():object( sobj.id )
  sobj.squad = SQUAD
  local ini = sobj:spawn_ini()
  ini.readonly = false
  ini:w_bool( "battle", "spawned", true )
  if self.cleanup == false then
    ini:w_bool( "battle", "cleanup", false )
  end
  if db.actor:has_info( "volna_goodwill" ) then
    ini:w_bool( "battle", "volna_goodwill", true )
  end
  if self.actor_is_enemy then
    ini:w_bool( "battle", "xrs_battle_ai.actor_is_enemy", true )
  end
  sobj:save_spawn_ini()
  return sobj
end


function battle_wave:create_enemies( t, each_f )
  for _, args in ipairs( t ) do
    local sobj = self:create_enemy( unpack( args ) )
    if each_f then each_f( sobj ) end
  end
end


local teleport_particle = particles_object( "anomaly2\\teleport" )
local teleport_snd = sound_object( "anomaly\\teleport_work_2" )

function battle_wave:create_enemies_like_teleport( t )
  local positions, vertexes = {}, {}
  self:create_enemies(
    t,
    function( sobj )
      if vertexes[ sobj.m_level_vertex_id ] then return end
      local lpos = level.vertex_position( sobj.m_level_vertex_id )
      for _, pos in ipairs( positions ) do
        if pos:distance_to( lpos ) < 5 then return end
      end
      vertexes[ sobj.m_level_vertex_id ] = true
      table.insert( positions, lpos )
      teleport_particle:play_at_pos( lpos )
      teleport_snd:play_no_feedback( db.actor, sound_object.s3d, 0, lpos, 1.0 )
    end
  )
end


function battle_wave:create_enemies_like_alife( t )
  for _, args in ipairs( t ) do
    local sobj = alife():create( unpack( args ) )
  end
end


function create_enemy( ... )
  return battle_wave({}):create_enemy( ... )
end

function create_enemies( ... )
  return battle_wave({}):create_enemies( ... )
end

function create_enemies_like_teleport( ... )
  return battle_wave({}):create_enemies_like_teleport( ... )
end

function create_enemies_like_teleport2( timer_id, t )
  local by_lvid = {}
  local groups  = {}
  for _, item in ipairs( t ) do
    local sect, pos, lvid, gvid = unpack( item )
    if by_lvid[ lvid ] then
      table.insert( by_lvid[ lvid ], item )
    else
      by_lvid[ lvid ] = { item }
      table.insert( groups, by_lvid[ lvid ] )
    end
  end
  create_enemies_like_teleport3( table.remove( groups, 1 ) )
  for i, g in ipairs( groups ) do
    ogse_st_mgr.start_timer(
      timer_id .. i, teleport_particle:length() * i / 1000,
      script_name() .. ".create_enemies_like_teleport3", g
    )
  end
end

function create_enemies_like_teleport3( ... )
  db.actor:give_info_portion( "volna_goodwill" )
  battle_wave({}):create_enemies_like_teleport( ... )
  db.actor:disable_info_portion( "volna_goodwill" )
end


function is_volna_monster( obj )
  return volna_monsters[ obj:id() ]
end


-- Универсальный скрипт больших битв с монстрами/неписями
-- Поддерживаются:
-- Спавн по таймеру каждой волны монстров
-- Передышки между волнами
-- Спавн неподалеку от гг рюкзака с патронами/аптечками по время
-- передышки с выдачей информации через СМС
-- Монстры спавнятся не вокруг ГГ, а в определенном секторе справа,
-- слева или сзади ГГ рандомно, на указанном удалении. Спереди не
-- спавнятся.
-- "Быстрый" уборщик, который во избежание тормозов убирает скопления
-- трупов монстров при удалении гг от них на определенное расстояние
-- начало битвы запускается так:
-- amk.start_timer("battle", 0, {"level", num, 1})
-- где
-- level - уровень, на котором битва;
-- num - номер битвы на уровне;
-- 1 - начинаем с первой волны
--
-- Замечания:
--
-- Вместо монстров можно прописывать секции неписей (монолита,
-- например). Только уборщик не будет убирать их трупы.
--
-- Если в одной из волн прописать секции дружественных неписей - то
-- они также заспавнятся и будут воевать на стороне гг.

-- расстояние от ГГ в м, на котором уборщик убирает трупы
local cleanup_distance          = 50
-- время передышки в секундах (добавляется ко времени следущей волны
-- +-20%)
local rest_timeout              = 180
-- минимальная дистанция, на которой можно спавнить волну. если
-- подходящий вертекс на указанном расстоянии или дальше не находится
-- (гг заныкался в закутке - не находится в открытом месте) то спавн
-- волны откладывается
local min_good_distance         = 20
-- время в реальных с, на которое откладывается спавн след волны, если
-- гг заныкался
local min_good_distance_timeout = 10

-- общее количество заспавненных монстров с момента последней
-- передышки
local monster_cnt = 0

-- лекарства для рюкзака
local medkits = { "medkit", "medkit_army", "medkit_scientic", "bandage" }


function get_battles( level )
  local filename = "battle_" .. level
  local m = _G[ filename ]
  ASSERT(
    m, "[%s]: Failed to load '%s'", script_name(), filename
  )
  ASSERT(
    type( m ) == "table",
    "[%s]: Failed to load '%s', must be a table",
    script_name(), filename
  )
  ASSERT(
    m.battles, "[%s]: Failed to load '%s': battles not found",
    script_name(), filename
  )
  return m.battles
end


-- Основной обработчик. Вызывает сам себя через таймер. И первый
-- запуск нужно делать тоже через таймер.
function show_must_go_on_delayed( lvl, btl, wave )
  show_must_go_on_real( lvl, btl, tonumber( wave ) )
end


function show_must_go_on_real( lvl, btl, wave )
  if not wave then wave = 1 end
  local cur_wave = battle_wave( get_battles( lvl )[ btl ][ wave ] )

  -- сменили локу - битва закончена
  if not cur_wave.any_level then
    if level.name() ~= lvl then
      add_deferred_battle( lvl, btl, wave )
      show_off()
      return
    end
  end

  if db.actor:has_info( "battle" ) and wave == 1 then
    log2(
      "[%s]: found current battle in progress, defer new battle %s",
      script_name(), get_timer_name( lvl, btl, wave )
    )
    add_deferred_battle( lvl, btl, wave )
    return
  end

  db.actor:give_info_portion( "battle" )
  if cur_wave.info then
    -- выдаем поршень
    local t = type( cur_wave.info ) == "table"
      and cur_wave.info or { cur_wave.info }
    for _, i in ipairs( t ) do
      db.actor:give_info_portion( i )
    end
  end
  if cur_wave.disable_info then
    local t = type( cur_wave.disable_info ) == "table"
      and cur_wave.disable_info or { cur_wave.disable_info }
    for _, i in ipairs( t ) do
      db.actor:disable_info_portion( i )
    end
  end

  -- спавн монстров/неписей
  if cur_wave.enemy then
    -- проверяем, не заныкался ли где гг в закутке - можно ли
    -- заспавнить на нормальном расстоянии от него
    local pos, lv
    if cur_wave.dist then
      pos, lv = get_pos( cur_wave.dist, get_sector() )
      local min_dist = math.min( cur_wave.dist, min_good_distance )
      if pos:distance_to( db.actor:position() ) < min_dist then
        -- заныкался - откладываем спавн, пока гг не выйдет из укрытия
        battle_timer( min_good_distance_timeout, lvl, btl, wave )
        return
      end
    end
    ASSERT(
      ( pos and lv ),
      "[%s]: [%s, %s, %s]: enemy without dist found",
      script_name(), lvl, btl, wave
    )
    local t  = {}
    local gv = cross_table():vertex( lv ):game_vertex_id()
    for s, p in pairs( cur_wave.enemy ) do
      if cur_wave.enemies_k then p = p * cur_wave.enemies_k end
      for i = 1, p do
        table.insert( t, { s, pos, lv, gv } )
      end
    end
    monster_cnt = monster_cnt + table.getn( t )
    local create_f = cur_wave.create and battle_wave[ cur_wave.create ]
      or battle_wave.create_enemies
    create_f( cur_wave, t )
  end

  if cur_wave.rest then
    -- есть перерыв
    if cur_wave.rukzak then
      -- есть тайник - спавним
      reinforcement_timer(
        math.random( cur_wave.timeout * 0.8, cur_wave.timeout * 1.2 ),
        lvl, btl, wave, monster_cnt
      )
    end
    -- даем передышку
    cur_wave.timeout = cur_wave.timeout + rest_timeout
    monster_cnt = 0
  end

  if cur_wave.func then
    -- выполняем функцию
    loadstring( cur_wave.func )()
  end
  if cur_wave.tip then
    -- выдаем смс
    news_manager.send_tip( db.actor, cur_wave.tip, nil, nil, 5000 )
  end

  -- следующая волна
  wave = wave + 1
  if get_battles( lvl )[ btl ][ wave ] then
    -- есть следующая волна - запускаем
    battle_timer( cur_wave.timeout, lvl, btl, wave )
  else
    -- конец битвы
    show_off()
  end
end


-- подкрепление в виде рюкзака
-- текущая волна должна идти параметром приватно, т.к. наверху уже
-- следующая волна на очереди
function reinforcement_delayed( lvl, btl, wave, last_monster_cnt )
  reinforcement(
    lvl, tonumber( btl ), wave, tonumber( last_monster_cnt )
  )
end


function reinforcement( lvl, btl, wave, last_monster_cnt )
  local cur_wave = get_battles( lvl )[ btl ][ wave ]
  ASSERT(
    cur_wave,
    "[%s]: %s, %s, %s: %s: wave not found",
    script_name(), lvl, btl, wave
  )

  -- сменили локу - битва закончена
  if not cur_wave.any_level then
    if level.name() ~= lvl then
      show_off()
      return
    end
  end

  -- рюкзак спавним с меткой и не далее 10 м от гг, чтобы нашел
  local pos, lv = get_pos( math.random( 3, 10 ) )
  local ruk = alife():create(
    "dsh_treasure_item", pos, lv, cross_table():vertex( lv ):game_vertex_id()
  )
  ruk = alife():object( ruk.id )
  ruk:used_ai_locations( false )
  level.map_add_object_spot_ser( ruk.id, "treasure",  "metka_battle_0" )
  local dsh_rukzak_id = "dsh_rukzak." .. ruk.id
  ogse.save_var( dsh_rukzak_id .. ".metka",    "metka_battle_0" )
  ogse.save_var( dsh_rukzak_id .. ".zamok",    false )
  ogse.save_var( dsh_rukzak_id .. ".inv_drop", true  )
  local items = {}

  -- аптечки
  if cur_wave.medkit then
    for i = 1, math.random(0, cur_wave.medkit ) do
      local sect = medkits[ math.random( table.getn( medkits ) ) ]
      if items[ sect ] then
        items[ sect ].count = items[ sect ].count + 1
      else
        items[ sect ] = {
          [ "count"     ] = 1,
          [ "game_type" ] = "medkit",
        }
      end
    end
  end

  -- патроны/подствол
  if cur_wave.ammo or cur_wave.podstvol then
    for i = 1, 2 do
      if db.actor:item_in_slot( i ) then
        local wpn = db.actor:item_in_slot( i )

        if cur_wave.ammo then
          for j = 1, math.floor( last_monster_cnt * cur_wave.ammo ) do
            local list = rx_utils.parse_list_new(
              nil, wpn:section(), "ammo_class"
            )
            local sect = list[ math.random( table.getn( list ) ) ]
            if items[ sect ] then
              items[ sect ].count = items[ sect ].count + 1
            else
              items[ sect ] = {
                [ "count"     ] = 1,
                [ "game_type" ] = "ammo",
              }
            end
          end
        end

        if cur_wave.podstvol and rx_utils.addon_attached( wpn, "gl" ) then
          for j = 1, math.floor( last_monster_cnt *cur_wave.podstvol ) do
            local list = rx_utils.parse_list_new(
              nil, wpn:section(), "grenade_class"
            )
            local sect = list[ math.random( table.getn( list ) ) ]
            if items[ sect ] then
              items[ sect ].count = items[ sect ].count + 1
            else
              items[ sect ] = {
                [ "count"     ] = 1,
                [ "game_type" ] = "ammo",
              }
            end
          end
        end
      end
    end
  end

  -- разный допхабар
  if cur_wave.items then
    for sect, t in pairs( cur_wave.items ) do
      if items[ sect ] then
        items[ sect ].count = t[ sect ].count + 1
      else
        items[ sect ] = t
      end
    end
  end

  local rukzak_items = {}
  for sect, t in pairs( items ) do
    ASSERT(
      ( t.count and t.game_type ),
      "[%s]: %s, %s, %s: %s: wrong item: count = %s, game_type = %s",
      script_name(), lvl, btl, wave, sect, tostring( t.count ),
      tostring( t.game_type )
    )
    table.insert(
      rukzak_items, dsh_rukzak.make_rukzak_item( sect, t.game_type, t.count )
    )
  end
  dsh_rukzak.save_rukzak( ruk.id, rukzak_items )

  -- выдаем смс
  if cur_wave.sms then
    news_manager.send_tip( db.actor, cur_wave.sms, nil, nil, 5000 )
  end
end


-- выбор сектора для спавна
function get_sector()
  return math.random( 3 ) * 90
end


-- определение места спавна. параметры:
-- dist - расстояние от ГГ
-- sector - в каком секторе спавнить (сзади, справа, или слева) от
-- ГГ. Сектор получать функцией get_sector(). Если не указан -
-- выполняется рандомный спавн вокруг гг (не нужно указывать для
-- рюкзаков)
-- Возвращает 2 значения: позицию спавна и левел_вертекс
function get_pos( dist, sector )
  local random_spawn = ( sector == nil )
  if not sector then sector = math.random( 360 ) end

  local actor_pos   = db.actor:position()
  -- угол обзора гг, если sector задан - то в видимой зоне не спавним
  local actor_fov   = math.rad( device().fov / 2 )
  local ai_step     = 0.7 -- шаг AI сетки
  local math_pi_180 = 180 / math.pi
  local pi2         = math.pi * 2

  -- выравниваем вектора по горизонтали
  local dir = device().cam_dir
  dir = vector():set( dir.x, 0, dir.z ):normalize()
  -- вектор взгляда актора, выравненный горизонтально
  local actor_dir = dir

  -- ищем вертекс по сектору
  dir = vector_rotate_y( dir, sector )
  while dist >= ai_step do
    -- итератор вращения направления
    local rotate_angle = math.asin( ai_step / dist )
    local cur_angle, cur_dir = 0, dir
    while math.abs( cur_angle ) < pi2 do
      local d1 = actor_dir:normalize()
      local d2 = cur_dir:normalize()
      if math.acos( d1:dotproduct( d2 ) ) > actor_fov then
        -- подходящий угол, ищем вертекс
        -- нужная нам позиция
        local pos     = vector():mad( actor_pos, cur_dir, dist )
        local vert_ok = level.vertex_id_by_pos( pos )
        if level.valid_vertex_id( vert_ok ) then
          local vert_pos = level.vertex_position( vert_ok )
          if no_anomaly_in( vert_pos ) then
            return vert_pos, vert_ok
          end
        end
      end
      -- поворачиваем направление поиска
      cur_angle = cur_angle + rotate_angle
      cur_dir   = vector_rotate_y( cur_dir, rotate_angle * math_pi_180 )
    end
    dist = dist - ai_step
  end

  -- прошлись по спирали и ничего не нашли
  return actor_pos, db.actor:level_vertex_id()
end


function show_off()
  monster_cnt = 0
  db.actor:disable_info_portion( "battle" )
  restore_deferred_battles()
end


-- "быстрый" уборщик
-- ускоренное удаление трупов при очень больших битвах. вызывается из апдейта
-- монстров
function cleanup( obj )
  ogse_signals.get_mgr():reschedule( math.random( 1000, 5000 ) )
  local dist = db.actor:position():distance_to( obj:position() )
  if
    dist > cleanup_distance and db.actor:alive()
    and not db.actor:see( obj )
  then
    local sobj = alife():object( obj:id() )
    if sobj then
      alife():release( sobj )
    end
  end
end

function cleanup_fast( obj )
  ogse_signals.get_mgr():reschedule( math.random( 1000, 5000 ) )
  if not db.actor:see( obj ) then
    local sobj = alife():object( obj:id() )
    if sobj then
      alife():release( sobj )
    end
  end
end


-- проверка попадания точки спавна в аномалию
function no_anomaly_in( pos )
  local anom_id, anom_pos, anom_radius, dist = amk_anoms.get_nearest_anomaly_for_pos( pos )
  return ( not anom_id ) or dist > 3
end


function get_timer_name( lvl, btl, wave )
  return string.format( "battle.%s.%s", lvl, btl )
end


function battle_timer( time, lvl, btl, wave )
  ogse_st_mgr.start_timer(
    get_timer_name( lvl, btl, wave ),
    time, "battle.show_must_go_on_delayed",
    lvl, btl, wave
  )
end


function reinforcement_timer( time, ... )
  ogse_st_mgr.start_timer( nil, time, "battle.reinforcement_delayed", ... )
end
