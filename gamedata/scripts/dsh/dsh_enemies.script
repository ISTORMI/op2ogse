-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm )
  sm:subscribe({ signal = "on_monster_death",       fun = this.on_death })
  sm:subscribe({ signal = "on_monster_enemy_callback", fun = this.enemy_callback })
  sm:subscribe({ signal = "on_monster_hit",         fun = this.on_hit   })
  sm:subscribe({ signal = "on_monster_net_destroy", fun = this.on_death })
  sm:subscribe({ signal = "on_npc_death",           fun = this.on_death })
  sm:subscribe({ signal = "on_npc_enemy_callback",  fun = this.enemy_callback })
  sm:subscribe({ signal = "on_npc_hit",             fun = this.on_hit   })
  sm:subscribe({ signal = "on_npc_net_destroy",     fun = this.on_death })
  sm:subscribe({ signal = "on_spawn",               fun = this.on_spawn })
end


local ignore_enemies = {}

function on_spawn()
  local dsh_sections = {
    "dsh.enemy.ignore",
    "dsh.enemy.ignore." .. level.name(),
  }
  for _, dsh_sect in ipairs( dsh_sections ) do
    if sys_ini:section_exist( dsh_sect ) then
      for _, k in ipairs( get_section_keys( dsh_sect ) ) do
        if not ignore_enemies[ k ] then
          ignore_enemies[ k ] = {}
        end
        local t = ignore_enemies[ k ]
        for _, n in ipairs( parse_names( get_string( dsh_sect, k ) ) ) do
          t[ n ] = true
        end
        for n, _ in pairs( t ) do
          if not ignore_enemies[ n ] then
            ignore_enemies[ n ] = {}
          end
          ignore_enemies[ n ][ k ] = true
        end
      end
    end
  end
  if level.name() == "l01_escape" then
    ogse_signals.get_mgr():subscribe({
      signal = "on_npc_spawn", fun = this.check_military_blockpost
    })
  end
end


-- некоторых сталкеров военные будут пропускать под мостом. А
-- некоторых - не будут.
local blockpost_pass = { "amk_embankment", "esc_bridge" }
function check_military_blockpost( obj )
  if math.random() > 0.7 then return end
  for _, k in ipairs( blockpost_pass ) do
    if not ignore_enemies[ k ] then ignore_enemies[ k ] = {} end
    ignore_enemies[ k ][ obj:name() ] = true
    if not ignore_enemies[ obj:name() ] then
      ignore_enemies[ obj:name() ] = {}
    end
    ignore_enemies[ obj:name() ][ k ] = true
  end
end


function mark_used( t, f )
  t[ 3 ] = f
end


function add_cache_rec( obj, enemy, is_enemy, ttl )
  local binder = obj:binded_object()
  local cached = binder[ "dsh_enemies.cached" ]
  if cached then
    local t = cached[ enemy:id() ]
    if t then
      t[ 1 ] = is_enemy
      t[ 2 ] = ttl
      mark_used( t, true )
    else
      cached[ enemy:id() ] = { is_enemy, ttl, true }
    end
  else
    binder[ "dsh_enemies.cached" ] = {
      [ enemy:id() ] = { is_enemy, ttl, true }
    }
  end
end


function get_cache_rec( obj, enemy, refresh )
  local is_enemy, fr
  local binder = obj:binded_object()
  local cached = binder[ "dsh_enemies.cached" ]
  if cached and cached[ enemy:id() ] then
    local t = cached[ enemy:id() ]
    local res, ttl = unpack( t )
    if ttl > time_global() then
      mark_used( t, true )
    elseif refresh then
      local was_enemy = res
      res, fr = check_is_enemy_always( obj, enemy )
      if res and not was_enemy then
        enable_memory_object( obj, enemy )
        if not enemy:is_actor() then
          enable_memory_object( enemy, obj )
        end
      end
    end
    is_enemy = res
  else
    is_enemy, fr = check_is_enemy_always( obj, enemy )
  end
  if fr then
    local ttl = time_global() + fr + math.random( fr / 10 )
    add_cache_rec( obj, enemy, is_enemy, ttl )
    if not enemy:is_actor() then
      add_cache_rec( enemy, obj, is_enemy, ttl )
    end
  end
  return is_enemy, fr
end


function enemy_callback( obj, enemy, result )
  local is_enemy, fr = get_cache_rec( obj, enemy )
  if fr then
    -- в кэш была добавлена новая запись или обновлена существующая
    local binder = obj:binded_object()
    local expire = binder[ "dsh_enemies.expire_cached" ]
    if expire then
      -- будим, что бы он пересчитал время для reschedule на следующем
      -- апдейте
      expire:weakup()
    else
      binder[ "dsh_enemies.expire_cached" ] = expire_cache( obj )
    end
  end
  if is_enemy == false then
    table.insert( result, is_enemy )
    return true
  end
end


-- как долго кешировать результат проверки
local combat_ignore_freq = 1000 -- для combat_ignore_cond
local far_freq =  5000          -- если слишком далеко
local freq     = 60000          -- в остальных случаях

function check_is_enemy_always( obj, enemy, recurse )
  local ignories = {
    this.get_ignore_by_community,
    this.get_ignore_by_name_or_strn,
  }
  for _, f in ipairs( ignories ) do
    local ignore = f( obj )
    if ignore then
      local strn = get_smart_terrain( enemy )
      for ignore_name, _ in pairs( ignore ) do
        if
          enemy:name() == ignore_name
          or ( enemy:is_stalker() and enemy:profile_name() == ignore_name )
          or is_ignored_community( enemy, ignore_name )
          or ( strn and strn:name() == ignore_name )
        then
          return false, freq
        end
      end
    end
  end
  if not is_enemy_by_dist( obj, enemy ) then
    return false, far_freq
  end
  if is_combat_ignore_cond( obj, enemy ) then
    return false, combat_ignore_freq
  end
  if not ( recurse or enemy:is_actor() ) then
    return check_is_enemy_always( enemy, obj, true )
  end
  return true, freq
end


function is_combat_ignore_cond( obj, enemy )
  if obj:is_stalker() then
    local st = db.storage[ obj:id() ].combat_ignore
    if st and st.action:enemy_callback( obj, enemy ) == false then
      return true
    end
  end
  return false
end


-- дальше этого расстояния сталкеры не должны ни с кем воевать, если
-- только их или их врага не видит актор
local too_far = 100

function is_enemy_by_dist( obj, enemy )
  if enemy:is_actor() then return true end
  if
    obj:is_stalker() and enemy:is_stalker()
    and obj:position():distance_to( enemy:position() ) > too_far
    and ( xr_wounded.is_wounded( obj ) or xr_wounded.is_wounded( enemy ) )
  then
    return false
  end
  if obj:is_stalker() or enemy:is_stalker() then
    local apos  = db.actor:position()
    local odist = apos:distance_to( obj:position() )
    local edist = apos:distance_to( enemy:position() )
    if
      odist > too_far and edist > too_far
      and not actor_see_them(obj, enemy)
    then
      return false
    end
  end
  return true
end

function actor_see_them( obj, enemy )
  if not db.actor:alive() then return false end
  return db.actor:see( obj ) or db.actor:see( enemy )
end


function get_ignore_by_community( obj )
  local keys = {}
  if obj:is_monster() then
    table.insert( keys, "monster" )
  elseif obj:is_stalker() then
    table.insert( keys, "human" )
    table.insert( keys, obj:character_community() )
  elseif obj:is_actor() then
    table.insert( keys, "actor" )
  end
  for _, k in ipairs( keys ) do
    if ignore_enemies[ k ] then
      return ignore_enemies[ k ]
    end
  end
end


function is_ignored_community( enemy, ignore_name )
  local keys = {}
  if enemy:is_monster() then
    table.insert( keys, "monster" )
  elseif enemy:is_stalker() then
    table.insert( keys, "human" )
    table.insert( keys, enemy:character_community() )
  elseif enemy:is_actor() then
    table.insert( keys, "actor" )
  end
  for _, k in ipairs( keys ) do
    if k == ignore_name then return true end
  end
  return false
end


function get_ignore_by_name_or_strn( obj )
  if ignore_enemies[ obj:name() ] then
    return ignore_enemies[ obj:name() ]
  elseif obj:is_stalker() and ignore_enemies[ obj:profile_name() ] then
    return ignore_enemies[ obj:profile_name() ]
  end
  local strn = get_smart_terrain( obj )
  if strn and ignore_enemies[ strn:name() ] then
    return ignore_enemies[ strn:name() ]
  end
end


function get_smart_terrain( obj, sobj )
  if obj and not sobj then
    sobj = alife():object( obj:id() )
  end
  if sobj and sobj.smart_terrain_id then
    local strn_id = dsh.is_free_logic_mob( sobj ) or sobj:smart_terrain_id()
    if strn_id ~= 65535 then
      local strn      = alife():object( strn_id )
      local begin_job = false
      if strn and strn:is_initialized() then
        -- strn:initialize_if_needed()
        begin_job = ( strn.gulag.Object_didnt_begin_job[ sobj.id ] == false )
      end
      return strn, begin_job
    end
  end
end


class "expire_cache"
function expire_cache:__init( obj )
  self.id   = obj:id()
  self.name = obj:name()
  self.sm   = ogse_signals.get_mgr()
  self:subscribe()
end

function expire_cache:subscribe()
  self.subscribed = self.sm:subscribe(
    {
      [ "signal" ] = "on_update",
      [ "fun"    ] = self.update,
      [ "self"   ] = self,
      [ "script_name" ] = "dsh_enemies.expire_cache." .. self.name,
    }
  )
end

function expire_cache:unsubscribe( binder )
  self.sm:unsubscribe( self.subscribed )
  self.subscribed = nil
  binder[ "dsh_enemies.expire_cached" ] = nil
end

function expire_cache:weakup()
  self.sm:weakup( self.subscribed )
end

function expire_cache:update()
  local obj = level.object_by_id( self.id )
  ASSERT(
    obj, "[%s]: object_by_id not found: id[%s] name[%s]",
    script_name(), self.id, self.name
  )
  ASSERT(
    obj:name() == self.name, "[%s]: different names: obj[%s] name[%s]",
    script_name(), obj:name(), self.name
  )
  local binder = obj:binded_object()
  local cached = binder[ "dsh_enemies.cached" ]
  ASSERT( cached, "[%s]: cached not found: name[%s]", script_name(), self.name )
  local min_ttl
  for enemy_id, data in pairs( cached ) do
    local is_enemy, ttl, used = unpack( data )
    local keep_cached = true
    if ttl <= time_global() then
      if used then
        local enemy = level.object_by_id( enemy_id )
        if
          enemy and ( enemy:is_custom_monster() or enemy:is_actor() )
          and enemy:alive()
        then
          local was_enemy = is_enemy
          get_cache_rec( obj, enemy, true )
          mark_used( data, false )
          is_enemy, ttl = unpack( cached[ enemy_id ] )
          if is_enemy and not was_enemy then
            enable_memory_object( obj, enemy )
            if not enemy:is_actor() then
              enable_memory_object( enemy, obj )
            end
          end
        else
          keep_cached = false
        end
      else
        keep_cached = false
      end
      if not keep_cached then
        cached[ enemy_id ] = nil
        if not is_enemy then
          local enemy = level.object_by_id( enemy_id )
          if enemy then
            enable_memory_object( obj, enemy )
          end
        end
      end
    end
    if keep_cached then
      if min_ttl then
        if ttl < min_ttl then min_ttl = ttl end
      else
        min_ttl = ttl
      end
    end
  end
  if min_ttl then
    self.sm:reschedule( min_ttl - time_global() )
  else
    self:unsubscribe( binder )
  end
end


function on_death( obj )
  local binder = obj:binded_object()
  local expire = binder[ "dsh_enemies.expire_cached" ]
  if expire then
    expire:unsubscribe( binder )
  end
end


function on_hit( obj, amount, local_direction, who, bone_index )
  if not who then return end
  local binder = obj:binded_object()
  local cached = binder[ "dsh_enemies.cached" ]
  if cached and cached[ who:id() ] then
    local is_enemy, ttl = unpack( cached[ who:id() ] )
    if not is_enemy then
      cached[ who:id() ] = nil
    end
  end
  enable_memory_object( obj, who )
end
