-- -*- mode: lua; coding: windows-1251-dos -*-

-- как часто выполнять проверку на занятость рук (в мс)
local freq = 200


function attach( sm )
  sm:subscribe({
    signal = "on_busy_hands_check", fun = this.on_busy_hands_check
  })
  sm:subscribe({ signal = "on_key_up",         fun = this.on_key_up        })
  sm:subscribe({ signal = "on_monster_death",  fun = this.on_monster_death })
  sm:subscribe({ signal = "on_monster_net_destroy", fun = this.on_destroy  })
  sm:subscribe({ signal = "on_monster_spawn",  fun = this.on_monster_spawn })
  sm:subscribe({ signal = "on_npc_death",      fun = this.on_npc_death     })
  sm:subscribe({ signal = "on_npc_net_destroy",     fun = this.on_destroy  })
  sm:subscribe({ signal = "on_npc_spawn",      fun = this.on_npc_spawn     })
  sm:subscribe({ signal = "on_ph_net_destroy",      fun = this.on_destroy  })
  sm:subscribe({ signal = "on_ph_spawn",       fun = this.on_ph_spawn      })
  sm:subscribe({ signal = "on_spawn",          fun = this.on_spawn         })
end


local info_radius
function on_spawn()
  info_radius = get_actor_obj().inventory.take_dist * 4
end


function on_any_spawn( obj, binder, cfg )
  local s = {
    [ "signal" ] = "on_update",
    [ "self"   ] = obj,
    [ "fun"    ] = this.on_any_update,
  }
  if cfg then
    binder[ "dsh_busy_hands.cfg" ] = cfg
  else
    ASSERT(
      binder[ "dsh_busy_hands.cfg" ],
      "[%s]: dsh_busy_hands.cfg not found", script_name()
    )
  end
  binder[ "dsh_busy_hands.subscribed" ] = s
  ogse_signals.get_mgr():subscribe( s )
end


function on_monster_spawn( obj, binder )
  if obj:alive() then return end
  if get_bool( obj:section(), "dsh_busy_hands.need_hands", false ) then
    on_npc_spawn( obj, binder )
  else
    on_any_spawn( obj, binder, {
      [ "need_knife" ] = "dsh_cant_without_knife",
    })
  end
end


function on_npc_spawn( obj, binder )
  if obj:alive() then return end
  on_any_spawn( obj, binder, {
    [ "need_hands" ] = "dsh_busy_hands",
  })
end


function on_monster_death( obj, who )
  on_monster_spawn( obj, obj:binded_object() )
  obj:set_tip_text_default()
  obj:set_nonscript_usable( true )
end


function on_npc_death( obj, who )
  on_npc_spawn( obj, obj:binded_object() )
  obj:set_tip_text_default()
  obj:set_nonscript_usable( true )
end


function on_ph_spawn( obj, binder )
  if
    obj:is_inventory_box() or obj:section() == "dsh_treasure_item"
  then
    local cfg = {
      [ "need_hands"   ] = "dsh_busy_hands",
      [ "tip_text_def" ] = "st_search_treasure",
    }
    if obj:section() == "shadow_inventory" then
      cfg.change_can_take = true
      cfg.tip_text_def    = "Поднять"
    end
    on_any_spawn( obj, binder, cfg )
  elseif binder[ "dsh_busy_hands.cfg" ] then
    on_any_spawn( obj, binder )
  end
end


local near_objs = {}

function on_destroy( obj, binder )
  local subscribed = binder[ "dsh_busy_hands.subscribed" ]
  if subscribed then
    ogse_signals.get_mgr():unsubscribe( subscribed )
    binder[ "dsh_busy_hands.subscribed" ] = nil
  end
  binder[ "dsh_busy_hands.tip_text" ] = nil
  near_objs[ obj:id() ] = nil
end


function actor_has_knife()
  local active_item = db.actor:active_item()
  return (
    active_item and db.actor:active_slot() == 0
    and dsh.is_knife( active_item:section() )
  )
end


function actor_has_free_hands()
  local active_item = db.actor:active_item()
  return (
    (
      active_item
      and string.find( active_item:section(), "wpn_fist_", 1, true )
    )
    or ( not active_item )
  )
end


function on_any_update( obj )
  ogse_signals.get_mgr():reschedule( 5000 )
  if not db.actor then return end
  local dist = obj:position():distance_to( db.actor:position() )
  ogse_signals.get_mgr():reschedule(
    ( dist < info_radius and 0 )
    or ( dist < 25 and freq )
    or ( dist < 50 and 1000 ) or ( dist < 100 and 2000 )
    or math.random( 5000, 6000 )
  )
  if dist < info_radius then
    near_objs[ obj:id() ] = true
    on_any_update_check( obj )
  else
    near_objs[ obj:id() ] = nil
  end
end


function on_any_update_check( obj )
  local binder = obj:binded_object()
  local data   = {}
  ogse_signals.get_mgr():call( "on_busy_hands_check", obj, binder, data )
  local tip_text = "dsh_busy_hands.tip_text"
  if data.usable then
    if binder[ tip_text ] ~= data.tip_text then
      if data.tip_text then
        obj:set_tip_text( data.tip_text )
      else
        obj:set_tip_text_default()
      end
      obj:set_nonscript_usable( true )
      if data.change_can_take then
        set_item_takeable( obj )
      end
      binder[ tip_text ] = data.tip_text
      binder[ "dsh_busy_hands_nonusable" ] = false
    end
  else
    if binder[ tip_text ] ~= data.tip_text then
      obj:set_tip_text( data.tip_text )
      obj:set_nonscript_usable( false )
      if data.change_can_take then
        set_item_untakeable( obj )
      end
      binder[ tip_text ] = data.tip_text
      binder[ "dsh_busy_hands_nonusable" ] = true
    end
  end
end


function on_busy_hands_check( obj, binder, data )
  local cfg = binder[ "dsh_busy_hands.cfg" ]
  if not cfg then return end
  if cfg.need_knife and not GetShift() then
    if obj:object_count() == 0 then
      data.tip_text = cfg.empty_corpse or "dsh_empty_corpse"
      data.usable   = false
      if not battle.subscribed( obj, binder ) then
        local spawned = smart_monster_parts.spawned( obj, binder )
        if not ( spawned and spawned + 1000 < time_global() ) then
          battle.subscribe( obj, binder )
        end
      end
    elseif actor_has_knife() then
      data.usable   = true
    else
      data.tip_text = cfg.need_knife
      data.usable   = false
    end
  elseif actor_has_free_hands() then
    data.usable     = true
  else
    data.tip_text   = cfg.need_hands or "dsh_busy_hands"
    data.usable     = false
  end
  if data.usable then
    data.tip_text = cfg.tip_text_def or binder.dsh_tip_text
  end
  data.change_can_take = cfg.change_can_take
end


function on_key_up( key, bind )
  if key == DIK_keys.DIK_LSHIFT or key == DIK_keys.DIK_RSHIFT then
    for id, _ in pairs( near_objs ) do
      local obj = level.object_by_id( id )
      if obj then
        on_any_update_check( obj )
      end
    end
  end
end
