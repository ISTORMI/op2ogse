-- -*- mode: lua; coding: windows-1251-dos -*-

-- величина разряда
local step = 0.014
-- как часто выполняется разряд фонарика ( в милисекундах реального времени )
local freq = 31 * 1000

-- если заряд меньше этой величины, яркость начинает снижаться
max_brightness = 0.1


function attach( sm )
  sm:subscribe({ signal = "on_first_update", fun = this.on_first_update })
  sm:subscribe({ signal = "inv_drag_drop",   fun = this.inv_drag_drop  })
  sm:subscribe({ signal = "on_key_down",     fun = this.on_key_down    })
  sm:subscribe({ signal = "on_key_holding",  fun = this.on_key_hold    })
  sm:subscribe({ signal = "on_key_up",       fun = this.on_key_up      })
  sm:subscribe({ signal = "on_mm_return_game", fun = this.on_mm_return_game })
  sm:subscribe({ signal = "on_sleep_finished", fun = this.on_sleep_finished })
  sm:subscribe({ signal = "on_spawn",        fun = this.on_spawn       })
  sm:subscribe({ signal = "on_actor_update", fun = this.on_update      })
end


function on_spawn()
  rebind_use_torch()
end


local dik_use_torch
function rebind_use_torch()
  dik_use_torch = {}
  local data = dsh_cfg.get_data()
  if not data.torch then return end
  for _, kn in ipairs( parse_names( data.torch ) ) do
    local dik = keyname_to_dik( kn )
    ASSERT( dik, "keyname to dik not found: %s", kn )
    dik_use_torch[ dik ] = true
  end
  cmd2( "unbind", "torch" )
  cmd2( "unbind_sec", "torch" )
end


function on_mm_return_game()
  rebind_use_torch()
end


function on_first_update()
  local sm = ogse_signals.get_mgr()
  sm:subscribe({ signal = "on_drop",         fun = this.remove_torch })
  sm:subscribe({ signal = "on_item_to_ruck", fun = this.remove_torch })
  set_torch_mode()
end


local torch_mode = "off"
function set_torch_mode( k )
  if db.actor:alive() then
    local torch = db.actor:item_in_slot( 9 )
    if torch and torch:is_torch() then
      torch = get_torch_obj( torch )
      if torch.on then
        torch_mode = ogse.load_var( "dsh_torch.torch_mode", "near" )
        if torch_mode == "far" then
          set_far_mode( torch, k )
        elseif torch_mode == "near" then
          set_near_mode( torch, k )
        end
      else
        set_near_mode( torch, k )
        torch_mode = "off"
      end
    end
  end
end


local key_holded = false

function on_key_down( key, bind, press_time )
  if level.main_input_receiver() then return end
  if dik_use_torch[ key ] then
    key_holded = false
  end
end


function on_key_hold( key, bind, press_time )
  local torch = get_torch_key( key )
  if not torch then return end
  if not torch.on then return end
  if key_holded == press_time then return end
  key_holded = press_time
  on_key_up( key, bind )
end


function get_torch_key( key )
  if
    ( not dik_use_torch[ key ] ) or level.main_input_receiver() or db.eat
  then
    return
  end
  if not db.actor:alive() then return end
  local torch = db.actor:item_in_slot( 9 )
  if torch and torch:is_torch() then
    return get_torch_obj( torch )
  end
end


local skip_next_key_up = false
local snd = sound_object( "device\\nlc6\\pda\\dairy_click_1" )

function on_key_up( key, bind )
  if key_holded == true and dik_use_torch[ key ] then
    key_holded = false
    return
  end

  local torch = get_torch_key( key )
  if not torch then return end

  snd:play( db.actor, 0, sound_object.s2d )
  if torch.on then
    if key_holded then
      set_off_mode( torch )
      key_holded = true
    elseif torch_mode == "near" then
      set_far_mode( torch )
    else
      set_off_mode( torch )
    end
  else
    set_near_mode( torch, nil, true )
  end

  ogse.save_var( "dsh_torch.torch_mode", torch_mode )
end


function set_brightness( torch, r )
  torch:set_brightness( math.min( 1, r / max_brightness ) )
end


function set_near_mode( torch, r, switch_on )
  torch_mode = "near"
  if not r then r = get_torch_power() end
  torch:set_range( 30 * math.min( 1, r / max_brightness ) )
  torch:set_angle( math.rad( 90 ) )
  set_brightness( torch, r )
  if switch_on and not torch.on then
    torch:switch( true )
  end
end


function set_far_mode( torch, r, switch_on )
  torch_mode = "far"
  if not r then r = get_torch_power() end
  torch:set_range( 70 * math.min( 1, r / max_brightness ) )
  torch:set_angle( math.rad( 55 ) )
  set_brightness( torch, r )
  if switch_on and not torch.on then
    torch:switch( true )
  end
end


function set_off_mode( torch )
  torch_mode = "off"
  torch:switch( false )
end


function is_torch_enabled( torch )
  if db.actor:alive() then
    if not torch then
      torch = db.actor:item_in_slot( 9 )
    end
    if torch and torch:is_torch() then
      torch = get_torch_obj( torch )
      if torch.on then
        return torch_mode
      end
      return false
    end
  end
end


function play_click()
  snd_obj = xr_sound.get_safe_sound_object( [[device\click10b]] )
  if snd_obj then
    snd_obj:play_no_feedback(
      db.actor, sound_object.s2d, 0, vector():set( 0, 0, 0 ), 1.0
    )
  end
end


function get_torch_power( new, torch )
  if not torch then
    torch = db.actor:item_in_slot( 9 )
  end
  if not torch then return end
  if new then
    dsh.set_condition( torch, new )
  end
  return torch:condition()
end


function before_recharge_torch( torch )
  if not torch then
    torch = db.actor:item_in_slot( 9 )
  end
  torch = get_torch_obj( torch )
  if torch and torch.on then
    torch:switch( false )
    return true
  end
  return false
end


function recharge_torch( cond, torch, battery, switch_on )
  if not cond then cond = 1 end
  if not torch then
    torch = db.actor:item_in_slot( 9 )
  end
  get_torch_power( cond, torch )
  torch = get_torch_obj( torch )
  if torch then
    if switch_on then
      torch:switch( true )
    end
    if switch_on or torch.on then
      set_torch_mode()
    end
  end
  if battery then
    ogse.remove_item_from_inventory( battery )
  end
end


local flash_t
function discharge_torch()
  if torch_mode == "off" then return end
  local torch = db.actor:item_in_slot( 9 )
  if not ( torch and torch:is_torch() ) then return end
  local power = get_torch_power()
  if power < max_brightness and math.random() < 0.2 then
    set_torch_mode( power * ( math.random( 5, 9 ) ) / 10 )
    if flash_t then flash_t:stop() end
    flash_t = dsh.rt_timeout(
      500 + 500 * math.random( 5 ),
      function()
        flash_t = nil
        discharge_torch()
      end
    )
  else
    local k   = 1 -- ( torch_mode == "near" and 1 or 2 )
    local dec = step * k
    if power > dec then
      get_torch_power( power - dec )
      set_torch_mode()
    else
      get_torch_power( 0 )
      torch = get_torch_obj( torch )
      torch:switch( false )
      torch_mode = "off"
    end
  end
end


local started = false
function on_update()
  ogse_signals.get_mgr():reschedule( freq )
  if started then
    discharge_torch()
  else
    started = true
  end
end


function on_sleep_finished( sleep_time )
  if torch_mode == "off" then return end
  get_torch_power( 0.13 )
  set_torch_mode()
end


function inv_drag_drop( obj, me )
  if not ( me:is_torch() and obj:section() == "batt_torch" ) then return end
  if me:condition() > 0.99 then
    ogse.autohiding_msg( "Фонарик не нуждается в подзарядке", 1500 )
    return true
  end
  dsh_hud_fx.run_fx_on_update(
    obj:section(), "recharge_torch", nil,
    {
      [ "battery"   ] = obj,
      [ "condition" ] = obj:condition(),
      [ "section"   ] = obj:section(),
      [ "torch"     ] = me,
    }
  )
  return true
end


function remove_torch( obj )
  if obj:is_torch() then
    local torch = get_torch_obj( obj )
    if torch.on then
      set_off_mode( torch )
      ogse.save_var( "dsh_torch.torch_mode", torch_mode )
    end
  end
end
