-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm ) -- для менеджера сигналов
  sm:subscribe({ signal = "on_first_update",   fun = this.on_first_update   })
  sm:subscribe({ signal = "on_sleep_finished", fun = this.on_sleep_finished })
  sm:subscribe({ signal = "on_use",            fun = this.on_item_use       })
end


local last_matras_used     = false
local monsters_can_find_me = false

function on_sleep_finished( sleep_seconds )
  local sleep_minutes = math.floor( sleep_seconds / 60 )
  reduce_need_sleep( sleep_minutes )
  if monsters_can_find_me then
    monsters_can_find_me = false
    monsters_found_me( sleep_seconds )
  end
  if last_matras_used then
    local cond = last_matras_used:condition()
    if cond > 0.1 then
      dsh.set_condition( last_matras_used, cond - 0.1 )
    else
      dsh.set_condition( last_matras_used, 0 )
    end
    last_matras_used = false
  end
end


function on_first_update()
  cant_sleep_timer( 30000 )
  dsh.timeout(
    math.random( 3 ) * 1000,
    function()
      ogse_signals.get_mgr():subscribe(
        { signal = "on_update", fun = this.on_update }
      )
    end
  )
end


local time_factor = get_float( "alife", "time_factor" )
local sleep_step  = math.floor( 360 / time_factor ) * 1000

function on_update()
  ogse_signals.get_mgr():reschedule( sleep_step )
  if not ogse_sleep_mgr.is_sleep_active() then
    test_for_need_sleep()
  end
end


function on_item_use( obj )
  local section = obj:section()
  if section == "matras" then
    if obj:condition() > 0 then
      if
        level.rain_factor() > 0
        and not ( isIndoor( level.name() ) or level.is_actor_indoor() )
      then
        ogse.autohiding_msg( game.translate_string( "sleep_raining" ), 1500 )
      elseif not ogse_campfire.find_nearest_flame_pos( 10 ) then
        ogse.autohiding_msg(
          game.translate_string( "sleep_want_campfire" ), 1500
        )
      else
        last_matras_used = obj
        if not test_for_need_sleep_impl() then
          last_matras_used = false
        end
      end
    else
      ogse.autohiding_msg( game.translate_string( "sleep_bad_matras" ), 1500 )
    end
    return true -- матрас больше никому не надо использовать
  end
end


function reduce_need_sleep( minutes )
  local gg_need_sleep = get_gg_need_sleep()
  gg_need_sleep = gg_need_sleep - math.floor( minutes / 3 * restore_coef() )
  if gg_need_sleep < 0 then gg_need_sleep = 0 end
  set_gg_need_sleep( gg_need_sleep )
  test_sleep_pp()
end


function restore_coef()
  local coef = 1
  -- вещи в слотах мешают выспаться быстрее
  for n, _ in pairs( dsh.small_wpn_slots ) do
    if db.actor:item_in_slot( n )  then coef = coef * 0.90 end
  end
  if db.actor:item_in_slot( 2 )    then coef = coef * 0.90 end
  if db.actor:get_current_outfit() then coef = coef * 0.85 end
  if ogse_actor_conditions_mgr.has_overweight then coef = coef * 0.85 end
--  if get_shadow_inv():update_storage() then coef = coef * 0.85 end
  return coef
end


function get_gg_need_sleep()
  return ogse.load_var( "dsh_sleep.gg_need_sleep", 0 )
end

function set_gg_need_sleep( v )
  ogse.save_var( "dsh_sleep.gg_need_sleep", v, "u16" )
end

function add_gg_need_sleep( add )
  set_gg_need_sleep( get_gg_need_sleep() + add )
end

function change_gg_need_sleep( v )
  add_gg_need_sleep( v )
  test_sleep_pp()
end


local zevota_flag = 0
function test_sleep_pp()
  local gg_need_sleep = get_gg_need_sleep()
  if gg_need_sleep > 250 then
    if not is_cant_sleep() then
      last_matras_used = false
      ogse_sleep_mgr.begin_sleep( 9 + dsh_energy_drink.get_energy_drink_n() )
      local cat = are_cats_near()
      if cat then return db.actor:kill( cat ) end
    end
  elseif gg_need_sleep > 244 then
    zevota()
    level.add_pp_effector( "black.ppe", 105, false )
    if zevota_flag ~= 3 then
      zevota_flag = 3
      level.add_pp_effector( "yantar_underground_psi.ppe", 999, true )
      level.set_pp_effector_factor( 999, 7.5 )
    end
  elseif gg_need_sleep > 190 then
    if zevota_flag ~= 2 then
      zevota()
      level.add_pp_effector( "black.ppe", 105, false )
      zevota_flag = 2
      level.add_pp_effector( "yantar_underground_psi.ppe", 999, true )
      level.set_pp_effector_factor( 999, 5.0 )
    end
  elseif gg_need_sleep > 185 then
    if zevota_flag ~= 1 then
      zevota()
      zevota_flag = 1
      level.remove_pp_effector( 999 )
    end
  else
    if zevota_flag ~= 0 then
      zevota_flag = 0
      level.remove_pp_effector( 999 )
    end
  end
end


function test_for_need_sleep( add )
  add_gg_need_sleep( add or 1 )
  test_sleep_pp()
end


function test_for_need_sleep_matras()
  last_matras_used = false
  test_for_need_sleep_impl()
end


function test_for_need_sleep_impl( check_best_enemy )
  if
    db.actor:has_info( "horror_time_begin" )
    and db.actor:dont_has_info( "horror_fail" )
  then
    if not meceniy_utils.check_for_horror_time() then
      db.actor:disable_info_portion( "horror_time_begin" )
    end
  end
  local actorPos  = db.actor:position()
  local enemy     = false
  local friends   = false
  for npcId, is_stalker in pairs( db.creature ) do
    local obj = level.object_by_id( npcId )
    if obj and obj:alive() then
      local is_enemy_to_actor = false
      if
        string.find( obj:section(), "rat_", 1, true )
        and not dsh_rats.rats_evil_here()
      then
        is_enemy_to_actor = false
      else
        is_enemy_to_actor = xrs_battle_ai.check_is_enemy( obj, db.actor )
      end
      local dist = obj:position():distance_to( actorPos )
      if is_enemy_to_actor then
        if
          dist < 20 or obj:see( db.actor )
          or (
            check_best_enemy and obj:best_enemy() and obj:best_enemy():is_actor()
          )
          or (
            check_best_enemy and is_stalker
            and xrs_battle_ai.has_actor_in_targets( obj )
          )
        then
          enemy = true
          break
        end
      elseif is_stalker then
        friends = true
        break
      end
    end
  end
  if enemy then
    ogse.autohiding_msg(
      game.translate_string( "not_need_sleep_enemy" ), 1500
    )
  elseif
    db.actor:has_info( "pre_blowout" )
    or dsh_cop_weather.get_weather_mgr():is_surge_in_process()
    or (
      amk.load_variable( "blowout", -1 ) > -1
      and amk.load_variable( "blowout", -1 ) < 5
    )
    or surge_soon()
  then
    ogse.autohiding_msg( game.translate_string( "blowout_not_sleep" ), 1500 )
  elseif
    db.actor:has_info( "horror_time_begin" )
    and db.actor:dont_has_info( "horror_fail" )
  then
    ogse.autohiding_msg(
      game.translate_string( "not_need_sleep_in_hell" ), 1500
    )
  elseif dsh_energy_drink.is_energy_drink_in_use() and zevota_flag < 2 then
    ogse.autohiding_msg(
      game.translate_string( "not_need_sleep_nrg" ), 1500
    )
  else
    if
      ( get_gg_need_sleep() > 60 and not is_cant_sleep() )
      or (
        has_alife_info( "snp_shadows_start" )
        and not has_alife_info( "snp_shadows_done" )
      )
    then
      -- звуковое сопровождение
      local snd = xr_sound.get_safe_sound_object( "zwuk\\inv_sleeping" )
      snd:play_no_feedback( db.actor, sound_object.s2d, 0, vector():set( 0, 0, 0 ), 2.0 )
      -- закрываем инвентарь
      local wnd = level.main_input_receiver()
      if wnd then
        wnd:GetHolder():start_stop_menu( wnd, true )
      end
      -- запоминаем, делать ли подлянку
      if friends then
        monsters_can_find_me = false
      else
        monsters_can_find_me = amk_anoms.check_hideouts( db.actor:position() )
      end
      -- открываем диалог сна
      level.disable_input()
      dsh.rt_timeout(
        snd:length(),
        function()
          level.enable_input()
          level.start_stop_menu( ui_sleep.sleep(), true )
        end
      )
      return true
    else
      ogse.autohiding_msg( game.translate_string( "not_need_sleep" ), 1500 )
    end
  end
  return false
end


local zevota_sound = {
  sound_object( "characters_voice\\human_06\\newbie\\states\\idle\\idle_34"  ),
  sound_object( "characters_voice\\human_03\\stalker\\states\\idle\\idle_33" ),
}

function zevota()
  local snd = zevota_sound[ math.random( table.getn( zevota_sound ) ) ]
  snd:play_no_feedback(
    db.actor, sound_object.s2d, 0, vector():set( 0, 0, 0 ), 1.0
  )
end


function are_cats_near()
  local pos = db.actor:position()
  for id, is_stalker in pairs( db.storage ) do
    local obj = level.object_by_id( id )
    if obj and obj:clsid() == clsid.cat_s and obj:alive() then
      local dist = obj:position():distance_to( pos )
      if dist < 15 then return obj end
    end
  end
end


function monsters_found_me( sleep_seconds )
  local sleep_hours = math.floor( sleep_seconds / 3600 )
  local need_cnt    = math.random( math.max( 4, sleep_hours ) )
  local monsters    = {}
  for id, is_npc in pairs( db.creature ) do
    if not is_npc then
      local obj = level.object_by_id( id )
      if
        obj and obj:alive() and obj:relation( db.actor ) == game_object.enemy
        and not string.find( obj:section(), "rat_", 1, true )
      then
        table.insert( monsters, obj )
        if table.getn( monsters ) == need_cnt then break end
      end
    end
  end
  local actor_pos = db.actor:position()
  table.sort(
    monsters,
    function( a, b )
      return a:position():distance_to( actor_pos ) < b:position():distance_to( actor_pos )
    end
  )
  for _, obj in ipairs( monsters ) do
    dsh_mob_home.create_home( obj, nil, 10, 20, true, true )
  end
end


function want_sleep_k()
  local n1, n2        = 185, 250
  local gg_need_sleep = get_gg_need_sleep()
  if gg_need_sleep > n2 then
    return 1
  elseif gg_need_sleep <= n1 then
    return 0
  else
    return ( gg_need_sleep - n1 ) / ( n2 - n1 )
  end
end


local cant_sleep_t = false
function cant_sleep_timer( t )
  if cant_sleep_t then
    local elapsed = cant_sleep_t:elapsed()
    if elapsed > t then return end
  end
  can_sleep_t = dsh.timeout( t, function() cant_sleep_t = false end )
end
function is_cant_sleep()
  return
    db.actor:has_info( "pre_blowout" )
    or dsh_cop_weather.get_weather_mgr():is_surge_in_process()
    or (
      amk.load_variable( "blowout", -1 ) > -1
      and amk.load_variable( "blowout", -1 ) < 5
    )
    or surge_soon()
    or ogse_surge_mgr.is_autosave_active()
    or cant_sleep_t
end


function surge_soon()
  local surge_hours = dsh_cop_weather.get_surge_time()
  return surge_hours < 0.25     -- до выброса меньше 15-ти минут
end
