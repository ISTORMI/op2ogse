-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm )
  sm:subscribe({ signal = "inv_drag_drop", fun = this.drag_drop_reload_next_ammo })
  sm:subscribe({ signal = "on_inventory_hide", fun = this.on_inventory_hide })
  sm:subscribe({ signal = "on_destroy",  fun = this.on_destroy  })
  sm:subscribe({ signal = "on_key_down", fun = this.on_key_down })
  sm:subscribe({ signal = "on_mm_return_game", fun = this.on_mm_return_game })
  sm:subscribe({ signal = "on_spawn",    fun = this.on_spawn    })
end


local rummaged_wnd
function wnd()
  return rummaged_wnd
end


function on_spawn()
  rebind_keys()
  set_inventory_exit()
  rummaged_wnd = rummaged()
end


function on_destroy()
  rummaged_wnd:dsh_unregister_self()
  rummaged_wnd = nil
end


local dik_inv_open, k_inv_open

function rebind_keys()
  dik_inv_open = {}
  local data = dsh_cfg.get_data()
  if not data.chat then return end
  for _, kn in ipairs( parse_names( data.inventory ) ) do
    local dik = keyname_to_dik( kn )
    ASSERT( dik, "keyname to dik not found: %s", kn )
    dik_inv_open[ dik ] = true
    k_inv_open = dik
  end
  cmd2( "unbind", "inventory" )
  cmd2( "unbind_sec", "inventory" )
end


function on_mm_return_game()
  rebind_keys()
end


function set_inventory_exit()
  local wnd      = level.get_inventory_wnd()
  local btn_exit = wnd:FindChild( "exit_button" )
  if btn_exit then
    local btn = btn_exit:GetButton()
    if btn then
      btn:SetAccelerator( k_inv_open )
    end
  end
end


local remembered_active_item_id
function remember_active_item()
  if db.actor:active_item() then
    remembered_active_item_id = db.actor:active_item():id()
  else
    remembered_active_item_id = nil
  end
end

function forget_active_item()
  remembered_active_item_id = nil
end

function on_key_down( key, bind )
  if ( not dik_inv_open[ key ] ) or level.main_input_receiver() or db.eat then
    return
  end
  remember_active_item()
  db.actor:hide_weapon()
  wnd():ReInitIcons()
  level.start_stop_menu( wnd(), true )
  return true
end


class "rummaged" ( dsh_ui.dshCUIScriptWnd )
function rummaged:__init() super()
  self:InitControls()
  self:ReInitIcons()
end

function rummaged:__finalize() end


function rummaged:InitControls()
  -- Положение и размеры окна
  self:Init( 246, 0, 533, 722 )

  local xml = CScriptXmlInit()
  xml:ParseFile( "ui_cheat_inv_buttons.xml" )

  xml:InitStatic( "background_glass", self )
  xml:InitStatic( "background", self )
  -- Кнопка ВЫХОД
  xml:InitStatic( "btn_exit_back", self )

  -- Кнопка выхода
  local btn_exit = xml:Init3tButton( "btn_stop", self )
  btn_exit:SetAccelerator( k_inv_open, 0 )
  self:Register( btn_exit, "btn_stop" )
  self:dshAddCallback(
    "btn_stop", ui_events.BUTTON_CLICKED, self.on_quit, self
  )

  -- ставлю иконку костюма
  self.body_icon    = xml:InitStatic( "body_icon", self )
  self.rykzack_icon = xml:InitStatic( "rykzack_icon", self )

  xml:InitStatic( "background_ruk", self )
  -- Кнопка рюкзака (весь)
  self:Register( xml:Init3tButton( "btn_ruk", self ), "btn_ruk" )
  self:dshAddCallback(
    "btn_ruk", ui_events.BUTTON_CLICKED, self.btn_ruk, self
  )

  xml:InitStatic( "background_wpn", self )
  -- Кнопка рюкзака (ружья)
  self:Register( xml:Init3tButton( "btn_wpn", self ), "btn_wpn" )
  self:dshAddCallback(
    "btn_wpn", ui_events.BUTTON_CLICKED, self.btn_wpn, self
  )

  xml:InitStatic( "background_belt", self )
  -- Кнопка рюкзака (пояс)
  self:Register( xml:Init3tButton( "btn_belt", self ), "btn_belt" )
  self:dshAddCallback(
    "btn_belt", ui_events.BUTTON_CLICKED, self.btn_belt, self
  )

  xml:InitStatic( "background_eat", self )
  -- Кнопка рюкзака (мелочевка)
  self:Register( xml:Init3tButton( "btn_eat", self ), "btn_eat" )
  self:dshAddCallback(
    "btn_eat", ui_events.BUTTON_CLICKED, self.btn_eat, self
  )

  self.sleep_bag_back = xml:InitStatic( "background_sleep", self )
  self.sleep_bag_back:Show( false )
  -- Кнопка спальника
  self.sleep_bag_btn  = xml:Init3tButton( "btn_sleep", self )
  self.sleep_bag_btn:Enable( false )
  self:Register( self.sleep_bag_btn, "btn_sleep" )
  self:dshAddCallback(
    "btn_sleep", ui_events.BUTTON_CLICKED, self.btn_sleep, self
  )

  self.flaska_back = xml:InitStatic( "background_fl", self )
  self.flaska_back:Show( false )
  -- Кнопка фляжки
  self.flaska_btn  = xml:Init3tButton( "btn_fl", self )
  self.flaska_btn:Enable( false )
  self:Register( self.flaska_btn, "btn_fl" )
  self:dshAddCallback( "btn_fl", ui_events.BUTTON_CLICKED, self.btn_fl, self )

  xml:InitStatic( "background_raz", self )
  -- Кнопка разгрузки
  self:Register( xml:Init3tButton( "btn_raz", self ), "btn_raz" )
  self:dshAddCallback(
    "btn_raz", ui_events.BUTTON_CLICKED, self.btn_raz, self
  )

  xml:InitStatic( "background_pod", self )
  -- Кнопка подсумка
  self:Register( xml:Init3tButton( "btn_pod", self ), "btn_pod" )
  self:dshAddCallback(
    "btn_pod", ui_events.BUTTON_CLICKED, self.btn_pod, self
  )
end


function rummaged:ReInitIcons()
  -- определяю костюм и иконку
  local armor = db.actor:get_current_outfit()
  local gg_icon
  if armor then
    -- костюм на ГГ есть
    gg_icon = get_string(
      armor:section(), "full_icon_name", "npc_icon_without_outfit"
    )
  else
    --  костюма нет
    gg_icon = "npc_icon_without_outfit"
  end
  self.body_icon:InitTexture( gg_icon )

  -- ставлю иконку сидорка
  local gg_rykzack
  if armor then
    gg_rykzack = get_string(
      armor:section(), "backpack_type", "ui_icon_rykzack_1_brown"
    )
  else
    gg_rykzack = "ui_icon_rykzack_1_brown"
  end
  self.rykzack_icon:InitTexture( gg_rykzack )

  if amk_utils.inventory_search( "flaska", 1 ) then
    self.flaska_back:Show(  true  )
    self.flaska_btn:Enable( true  )
  else
    self.flaska_back:Show(  false )
    self.flaska_btn:Enable( false )
  end

  if amk_utils.inventory_search( "matras", 1 ) then
    self.sleep_bag_back:Show(  true  )
    self.sleep_bag_btn:Enable( true  )
  else
    self.sleep_bag_back:Show(  false )
    self.sleep_bag_btn:Enable( false )
  end
end


function rummaged:OnKeyboard( dik, keyboard_action )
  CUIScriptWnd.OnKeyboard( self, dik, keyboard_action )
  if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
    -- на выход повесим Esc
    if dik == DIK_keys.DIK_ESCAPE then
      self:on_quit()
    end
  end
  return true
end


local podsumok_deselect = sound_object( "razgruzka\\podsumok_deselect" )

function rummaged:on_quit()
  podsumok_deselect:play( db.actor, 0, sound_object.s2d )
  self:GetHolder():start_stop_menu( self, true )
  db.actor:restore_weapon()
  forget_active_item()
end


local rykzack_open_long = sound_object( "rykzack\\rykzack_open_long" )

function rummaged:btn_ruk()
  rykzack_open_long:play( db.actor, 0, sound_object.s2d )
  dsh.timeout(
    rykzack_open_long:length(),
    function()
      level.pre_init_inventory()
      db.actor:restore_weapon()
      dsh.rt_exec_on_update(
        function()
          level.enable_input()
          level.start_stop_menu( level.get_inventory_wnd(), true )
        end
      )
    end
  )
  level.disable_input()
  self:GetHolder():start_stop_menu( self, true )
  level.add_cam_effector(
   "camera_effects\\item_use_fast.anm", 8063, false, "" )
  level.add_cam_effector( "camera_effects\\item_use.anm", 8064, false, "" )
end


function rummaged:show_inv_items( types, f, hide_only )
  local items = dsh_rukzak.get_actor_items( function() return true end )
  for _, item in ipairs( items ) do
    if types[ item.game_type ] or ( f and f( item ) ) then
      if not hide_only then
        for _, obj in ipairs( item.game_objs ) do
          set_item_inv_visible( obj )
        end
      end
    else
      for _, obj in ipairs( item.game_objs ) do
        set_item_inv_hidden( obj )
      end
    end
  end
  if level.main_input_receiver() then
    self:GetHolder():start_stop_menu( self, true )
  end
  level.pre_init_inventory()
  db.actor:restore_weapon()
  dsh.rt_exec_on_update(
    function()
      level.enable_input()
      level.start_stop_menu( level.get_inventory_wnd(), true )
    end
  )
end


local wpn_types = {
  [ "ammo"     ] = true,
  [ "gl"       ] = true,
  [ "grenade"  ] = true,
  [ "knife"    ] = true,
  [ "missile"  ] = true,
  [ "scope"    ] = true,
  [ "silencer" ] = true,
  [ "weapon"   ] = true,
}

function rummaged:btn_wpn()
  self:show_inv_items(
    wpn_types,
    function( t )
      return get_string( t.section, "dsh_babah_proxy.real" )
    end
  )
end


local belt_types = {
  [ "artefact" ] = true,
}

function rummaged:btn_belt()
  self:show_inv_items(
    belt_types,
    function( t )
      return get_bool( t.section, "belt", false )
    end
  )
end


local eat_types = {
  [ "antirad"  ] = true,
  [ "bottle"   ] = true,
  [ "eatable"  ] = true,
  [ "food"     ] = true,
  [ "medkit"   ] = true,
}

function rummaged:btn_eat()
  self:show_inv_items( eat_types )
end


function rummaged:btn_fl()
  local found
  if dsh_dirty_mask.get_max_portions() > 1 then
    amk_utils.inventory_iterate_section(
      "flaska",
      function( obj )
        if ( not found ) or obj:condition() < found:condition() then
          found = obj
        end
      end
    )
  else
    local res, t = amk_utils.inventory_search_check({ [ "flaska" ] = 1 })
    found = t[ 1 ]
  end
  ASSERT( found, "[%s]: flaska not found", script_name() )
  self:GetHolder():start_stop_menu( self, true )
  dsh_dirty_mask.use_flaska( found, true )
  db.actor:restore_weapon()
end


function rummaged:btn_sleep()
  self:GetHolder():start_stop_menu( self, true )
  local res, t = amk_utils.inventory_search_check({ [ "matras" ] = 1 })
  ASSERT( res, "unexpected result" )
  dsh_sleep.on_item_use( t[ 1 ] )
  db.actor:restore_weapon()
end


local unsubscribe_later = false
function rummaged:btn_raz()
  self:show_inv_items(
    {},
    function( t )
      if t.game_type == "ammo" then
        local incomplete = {}
        for _, obj in ipairs( t.game_objs ) do
          if obj:get_current_ammo() < obj:get_ammo_box_size() then
            table.insert( incomplete, obj )
          else
            set_item_inv_hidden( obj )
          end
        end
        if table.getn( incomplete ) > 0 then
          if table.getn( incomplete ) > 1 then
            for _, obj in ipairs( incomplete ) do
              set_item_inv_visible( obj )
              set_item_ungroupable( obj )
            end
          else
            set_item_inv_hidden( incomplete[ 1 ] )
          end
        end
        t.game_objs = {}
        return true
      end
      return false
    end, true
  )
  unsubscribe_later = ogse_signals.get_mgr():subscribe(
    { signal = "inv_drag_drop", fun = this.inv_drag_drop }
  )
end


function on_inventory_hide()
  db.actor:iterate_inventory(
    function( npc, obj )
      set_item_default_grouping( obj )
      set_item_inv_visible( obj )
    end,
    db.actor
  )
  if unsubscribe_later then
    ogse_signals.get_mgr():unsubscribe( unsubscribe_later )
    unsubscribe_later = false
  end
  forget_active_item()
end


local ammo_load_snd = sound_object( "razgruzka\\ammo_load" )

function inv_drag_drop( obj, me )
  if not ( me:is_ammo() and obj:is_ammo() ) then return end
  if me:id() == obj:id() or me:section() ~= obj:section() then return end
  if
    me:get_current_ammo() == me:get_ammo_box_size()
    and obj:get_current_ammo() == obj:get_ammo_box_size()
  then
    return
  end
  local need_ammo = me:get_ammo_box_size() - me:get_current_ammo()
  if need_ammo < obj:get_current_ammo() then
    me:set_ammo_box_curr( me:get_ammo_box_size() )
    obj:set_ammo_box_curr( obj:get_current_ammo() - need_ammo )
  else
    me:set_ammo_box_curr( me:get_current_ammo() + obj:get_current_ammo() )
    ogse.remove_item_from_inventory( obj )
  end
  if me:get_current_ammo() == me:get_ammo_box_size() then
    set_item_default_grouping( me )
    set_item_inv_hidden( me )
  end
  ammo_load_snd:play( db.actor, 0, sound_object.s2d )
  db.actor:invalidate_inventory()
  update_inventory_window()
end


local pod_items = {
  [ "acumm"      ] = true,
  [ "batt_torch" ] = true,
  [ "flaska"     ] = true,
  [ "matches"    ] = true,
}

function rummaged:btn_pod()
  self:show_inv_items(
    {},
    function( t )
      return pod_items[ t.section ]
    end
  )
end


function drag_drop_reload_next_ammo( obj, me )
  if not (
    -- me:id() == remembered_active_item_id and
    db.actor:is_in_slot( me )
    and me:is_weapon_magazined() and obj:is_ammo()
  ) then
    return
  end

  local sect = obj:section()
  local ammo_class = parse_names( get_string( me:section(), "ammo_class" ) )
  local next_ammo  = -1
  for i, ammo_sect in ipairs( ammo_class ) do
    if sect == ammo_sect then
      next_ammo = i - 1
      break
    end
  end

  if next_ammo >= 0 then
    level.disable_input()
    local id, seq     = dsh.assign_obj_seq( me )
    local target_slot = me:get_slot()
    dsh.rt_exec_on_update( function()
      dsh_hud_fx.close_inventory()
      db.actor:activate_slot( target_slot )
    end )
    dsh.rt_wait_condition(
      function() return db.actor:active_slot() == target_slot end,
      function()
        local wpn = dsh.get_object_by_id_seq( id, seq )
        if wpn then wpn:reload_next_ammo( next_ammo ) end
        level.enable_input()
      end
    )
    return true
  end
end


function btn_eat()
  db.actor:hide_weapon()
  wnd():btn_eat()
end
