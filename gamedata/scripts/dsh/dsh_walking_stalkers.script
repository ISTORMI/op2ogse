-- -*- mode: lua; coding: windows-1251-dos -*-

-- как долго можно оставаться в лагере дружественному сталкеру, после окончания
-- обязательно времени
local FRIENDS_MAX_STAY = 172800 -- два дня


local update_signal
function attach( sm )
  sm:subscribe({ signal = "on_begin_job_first_time", fun = this.on_begin_job })
  sm:subscribe({ signal = "on_empty_smart_terrain", fun = this.on_empty_smart })
  sm:subscribe({ signal = "on_full_smart_terrain",  fun = this.on_full_smart })
  sm:subscribe({ signal = "on_monster_first_update", fun = this.on_monster_first_update })
end


local gogogo_t
local update_gogogo = {}

function run_gogogo_timer()
  if not gogogo_t then
    gogogo_t = check_gogogo_timer():start()
  end
end

class "check_gogogo_timer" ( ogse_qt.quick_timer )
function check_gogogo_timer:__init() super()
  self.sm = ogse_signals.get_mgr()
end

function check_gogogo_timer:condition()
  return table.getn( update_gogogo ) == 0
end

function check_gogogo_timer:action()
  gogogo_t = nil
end

function check_gogogo_timer:update()
  if table.getn( update_gogogo ) > 0 then
    local t    = table.remove( update_gogogo, 1 )
    local sobj = se_monster.monsters[ t.id ] or se_stalker.stalkers[ t.id ]
    if sobj and sobj:alive() then
      if
        sobj:smart_terrain_id() == 65535
        and sobj:brain():can_choose_alife_tasks()
        and se_stalker.stalkers[ sobj.id ]
      then
        self:process_stalker( sobj )
      end
    end
  end
end

function check_gogogo_timer:process_stalker( sobj )
  xr_gulag.begin_walking_stalker()
  sobj:brain():update()
  xr_gulag.end_walking_stalker()
  if table.getn( update_gogogo ) > 0 then
    self:reschedule( 250 )
  end
end


function periodic_job()
  local gogogo = {}
  smart_terrain.iterate_smart_terrains( function( strn )
    strn:initialize_if_needed()
    local gulag = strn.gulag
    check_too_slow_npc( strn )
    if not is_walking_smart( strn ) then return end
    if gulag then
      for _, sobj in ipairs( get_walk_npc( strn ) ) do
        table.insert( gogogo, {
          [ "sobj" ] = sobj,
          [ "strn" ] = strn,
        })
      end
    end
  end )
  local rnd_go = {}
  while table.getn( gogogo ) > 0 do
    table.insert(
      rnd_go,
      table.remove( gogogo, math.random( table.getn( gogogo ) ) )
    )
  end
  for _, t in ipairs( rnd_go ) do
    local sobj = t.sobj
    local strn = t.strn
    if se_stalker.stalkers[ sobj.id ] and sobj.level_name ~= level.name() then
      local job = strn.gulag:getJob( sobj.id )
      if job and job.alife_task then
        sobj.last_alife_task = job.alife_task
      end
    end
    sobj:brain():can_choose_alife_tasks( true )
    smart_terrain.unregister_npc( sobj )
    cleanup_custom_data( sobj )
    table.insert( update_gogogo, {
      [ "id"   ] = sobj.id,
      [ "strn" ] = strn,
    })
    teleport_walking( sobj, t.strn )
  end
  run_gogogo_timer()
  local next_m = math.random( 0, 59 )
  dsh.start_gtimerDHMS(
    "dsh_walking_stalkers.periodic_job",
    0, 3, next_m, 0,
    "dsh_walking_stalkers.periodic_job"
  )
end


function get_smart_ini_section( strn )
  local name     = strn:name()
  local dsh_sect = "dsh.gulag.override." .. name
  local profile  = strn.dsh_active_profile
  local sect
  if profile then
    sect = dsh_sect .. "." .. profile
  else
    sect = dsh_sect
  end
  return sect
end


function is_walking_smart( strn )
  local name = strn:name()
  local res  = dsh.is_free_logic_gulag( name )
  local sect = get_smart_ini_section( strn )
  if
    sys_ini:section_exist( sect )
    and sys_ini:line_exist( sect, "dsh_walking" )
  then
    local cond = get_string( sect, "dsh_walking" )
    if cond then
      local pc = xr_logic.parse_condlist( nil, sect, "dsh_walking", cond )
      res = xr_logic.pick_section_from_condlist( db.actor, db.actor, pc ) ~= nil
    end
  end
  return res
end


function get_walk_npc( strn )
  local gulag = strn.gulag
  local sect  = get_smart_ini_section( strn )
  local keep_min = 0
  if sys_ini:section_exist( sect ) then
    keep_min = get_u32( sect, "dsh_walking_keep_min", keep_min )
  end
  local comed  = gulag:get_population_comed()
  local gogogo = {}
  if comed < keep_min + 1 then return gogogo end
  local comed_npc = {}
  for id, v in pairs( strn.npc_info ) do
    local npc_sobj = alife():object( id )
    if
      npc_sobj and npc_sobj:alive() and ( not v.exclusive )
      and ( not gulag.Object_didnt_begin_job[ id ] )
      and (
        check_npc_job( sect, id, gulag ) or check_npc_name( sect, npc_sobj )
      )
    then
      table.insert(
        comed_npc,
        {
          [ "diff_sec" ] = game.get_game_time():diffSec( v.stay_end ),
          [ "npc_info" ] = v,
          [ "sobj"     ] = npc_sobj,
        }
      )
    end
  end
  if table.getn( comed_npc ) > 0 then
    table.sort( comed_npc, function( a, b )
      return a.diff_sec > b.diff_sec
    end )
    local ready_to_go     = {}
    local not_ready_to_go = {}
    for _, v in ipairs( comed_npc ) do
      local sobj = v.sobj
      if v.diff_sec < 0 then
        table.insert( not_ready_to_go, v )
      elseif is_too_bad_weather( sobj ) then
        table.insert( not_ready_to_go, v )
      elseif is_too_late( sobj ) then
        table.insert( not_ready_to_go, v )
      elseif not amk_offline_alife.is_actors_friend( sobj ) then
        table.insert( ready_to_go,     v )
      elseif math.random() < ( v.diff_sec / FRIENDS_MAX_STAY ) then
        -- свои не должны начинать гулять на текущей локации, что бы
        -- глаза не мозолить своими брожениями и зверушек не тиранить
        if sobj.level_name == level.name() then
          local obj = level.object_by_id( sobj.id )
          if
            obj and (
              obj:position():distance_to( db.actor:position() ) < 100
              or ( db.actor:alive() and db.actor:see( obj ) )
            )
          then
            -- если он находится не слишком далеко или актор его видит,
            -- тогда пусть посидит еще
            table.insert( not_ready_to_go, v )
          else
            -- иначе пусть идет, его принудительно переведут в оффлайн и он
            -- исчезнет
            table.insert( ready_to_go, v )
          end
        else
          table.insert( ready_to_go, v )
        end
      end
    end
    local allowed_to_go = comed - keep_min
    local walkable      = math.min(
      allowed_to_go, table.getn( ready_to_go )
    )
    local num_to_go     = math.random( 0, walkable )
    if
      keep_min == 0         -- могут уйти все
      and num_to_go > 0
      and num_to_go == table.getn( ready_to_go ) -- идут все, кто собрался
      and table.getn( not_ready_to_go ) == 1     -- остается один
      and math.random() < 0.6
    then
      -- да ну нафиг, я тоже тогда пойду с мужиками.
      num_to_go = num_to_go + 1
      table.insert( ready_to_go, table.remove( not_ready_to_go ) )
    end
    while num_to_go > 0 do
      local npc_sobj = ready_to_go[ num_to_go ].sobj
      table.insert( gogogo, npc_sobj )
      num_to_go = num_to_go - 1
    end
  end
  return gogogo
end


function is_too_bad_weather( npc )
  if IsMonster( npc ) then return false end
  local weather = dsh_cop_weather.monitoring_weather_sect
  return (
    weather
    and ( weather == "storm" or weather == "veryfoggy" )
    and math.random() < 0.9
  )
end


function is_too_late( npc )
  if IsMonster( npc ) then return false end
  local htime = level.get_time_hours()
  if htime < 5 or htime > 21 then
    if math.random() < 0.8 then return true end
  end
  return false
end


function on_empty_smart( strn, sobj, begin_job )
  if not begin_job then return end
  local sect = get_smart_ini_section( strn )
  local change_on_empty, restrictors
  if sys_ini:section_exist( sect ) then
    change_on_empty = get_string( sect, "dsh_change_profile_on_empty" )
    restrictors     = get_string( sect, "dsh_cleanup_restrictors" )
  end
  if not change_on_empty then return end
  local cond = xr_logic.parse_condlist(
    nil, sect, "dsh_change_profile_on_empty", change_on_empty
  )
  if xr_logic.pick_section_from_condlist( db.actor, db.actor, cond ) == nil then
    return
  end
  local profiles
  if sys_ini:section_exist( sect ) then
    profiles = get_string( sect, "dsh_profiles" )
  end
  ASSERT( profiles, "profiles not found for %s", strn:name() )
  local new_profile = select_prob_name( parse_probs( profiles ) )
  switch_smart_terrain_profile( strn, new_profile )
  if restrictors then
    for _, k in ipairs( parse_names( restrictors ) ) do
      local sobj = alife():object( k )
      if sobj then
        alife():release( sobj )
      end
    end
  end
  delay_lock( strn, sect )
end


function delay_lock( strn, sect )
  local after_delay = get_string( sect, "dsh_after_delay" )
  if after_delay then
    local t1, t2 = unpack( parse_nums( after_delay ) )
    local delay  = math.random( t1, t2 )
    strn:set_idle_timer( delay )
  end
end
-- Оставлено для совместимости. Что бы не упало, если у кого-то в
-- сейве есть уже запущенный старый таймер.
function on_after_delay_timer() end


function parse_probs( str )
  local t = {}
  local last
  for _, k in ipairs( parse_names( str ) ) do
    if last then
      local p = tonumber( k )
      if p then
        last.prob = p
        last      = nil
      else
        last = {
          [ "name" ] = k,
          [ "prob" ] = 1,
        }
        table.insert( t, last )
      end
    else
      last = {
        [ "name" ] = k,
        [ "prob" ] = 1,
      }
      table.insert( t, last )
    end
  end
  return t
end


function select_prob_name( t )
  local sum = 0
  for _, v in ipairs( t ) do
    sum = sum + v.prob
  end
  ASSERT( sum > 0, "wrong sum = %s", sum )
  if sum > 1 then
    sum = math.random( 1, sum )
  end
  for _, v in ipairs( t ) do
    sum = sum - v.prob
    if sum <= 0 then
      return v.name
    end
  end
  ASSERT( nil, "nothing found: sum = %s", sum )
end


function switch_smart_terrain_profile( strn, profile )
  strn:set_active_profile( profile, true )
  strn:remove_gulag( strn.id, true )
end


function on_full_smart( strn )
  local sect = get_smart_ini_section( strn )
  local population_locked
  if sys_ini:section_exist( sect ) then
    population_locked = get_string( sect, "dsh_population_locked" )
  end
  if population_locked then
    local cond = xr_logic.parse_condlist(
      nil, sect, "dsh_population_locked", population_locked
    )
    if
      xr_logic.pick_section_from_condlist( db.actor, db.actor, cond ) ~= nil
    then
      strn:lock_population( true )
    end
  end
end


function check_too_slow_npc( strn )
  local max_time = 2 * 24 * 3600 -- 2 дня
  for id, v in pairs( strn.npc_info ) do
    local npc_sobj = alife():object( id )
    if
      npc_sobj
      and object_level_name( npc_sobj ) ~= object_level_name( strn )
    then
      local begin_job = (
        strn.gulag.Object_didnt_begin_job[ npc_sobj.id ] == false
      )
      local diff_sec  = game.get_game_time():diffSec( v.stay_end )
      if diff_sec > max_time and not begin_job then
        log2(
          "[%s] %s (%s) is too slow going to smart_terrain %s (%s): %s seconds till registration",
          script_name(),
          npc_sobj:name(),object_level_name( npc_sobj ),
          strn:name(), object_level_name( strn ),
          diff_sec
        )
        alife():teleport_object(
          id, strn.position, strn.m_level_vertex_id, strn.m_game_vertex_id
        )
      end
    end
  end
end


local walking_vertexes = {}

function reset_walking_vertexes( squad )
  walking_vertexes[ squad ] = nil
end


function walk_on_location( obj, squad, walk_together )
  local ai_step = 0.7 -- шаг AI сетки
  if not walking_vertexes[ squad ] then
    local pos, dir = obj:position(), obj:direction()
    local dist = math.random( 40, 300 )
    for i = 1, 10 do
      local vert_pos, vert_ok, vert_dir = dsh.get_random_pos_in_radius(
        dist, nil, pos, dir
      )
      if not vert_ok then return end
      walking_vertexes[ squad ] = vert_ok
      dist = dist - pos:distance_to( vert_pos )
      if dist < ai_step then break end
      pos = vert_pos
      dir = vert_dir
    end
  end
  local around_vertex = walking_vertexes[ squad ]
  if around_vertex then
    local minr, maxr
    if walk_together then
      minr, maxr = 10, 20
    else
      minr, maxr = 10, 50
    end
    dsh_mob_home.create_home( obj, around_vertex, minr, maxr, true, true )
  end
end


local walk_timers = {}

function on_monster_first_update( obj )
  if isIndoor( level.name() ) or not obj:alive() then return end
  local sobj = alife():object( obj:id() )
  if not sobj then return end
  local strn_id = dsh.is_free_logic_mob( sobj )
  if not strn_id then return end
  local strn = alife():object( strn_id )
  ASSERT( strn, "smart_terrain not found: %s", strn_id )
  if not is_walking_smart( strn ) then return end
  local walk_on = get_float(
    level.name(), "dsh_walk_on_location", true, game_ini()
  )
  local walk_together = true
  local sect = get_smart_ini_section( strn )
  if sys_ini:section_exist( sect ) then
    walk_on       = get_bool( sect, "dsh_walk_on_location", walk_on )
    walk_together = get_bool( sect, "dsh_walk_together",    walk_together )
  end
  if walk_on and not walk_timers[ strn_id ] then
    local squad = "dsh_walking_stalkers." .. strn:name()
    schedule_next_walk( strn, squad, walk_together )
  end
end


function on_begin_job( gulag, obj, sobj )
  if not gulag:dsh_is_free_logic() then return end
  if obj ~= true and IsMonster( obj ) then
    on_monster_first_update( obj )
  end
end


function schedule_next_walk( strn, squad, walk_together )
  local t = math.random( 5, 30 ) * 60 * 1000 -- от 5 до 30 реальных минут
  walk_timers[ strn.id ] = dsh.timeout(
    t,
    function()
      reset_walking_vertexes( squad )
      local cnt = 0
      for id, _ in pairs( strn.npc_info ) do
        local obj = level.object_by_id( id )
        if obj and obj:alive() then
          walk_on_location( obj, squad, walk_together )
          cnt = cnt + 1
        end
      end
      walk_timers[ strn.id ] = cnt > 0
        and schedule_next_walk( strn, squad, walk_together ) or nil
    end
  )
end


function check_npc_job( sect, id, gulag )
  if not sys_ini:section_exist( sect ) then return true end
  local sect_re = get_string(
    sect, "dsh_walking_stalkers.job_section"
  )
  if not sect_re then return true end
  local job = gulag:getJob( id )
  if not job then return true end
  if string.find( job.section, sect_re ) then
    return true
  end
  return false
end


function teleport_walking( sobj, strn )
  local sect = get_smart_ini_section( strn )
  if not sys_ini:section_exist( sect ) then return end
  local teleport_pp = get_string(
    sect, "dsh_walking_stalkers.teleport_pp"
  )
  if not teleport_pp then return end
  local path, pn = unpack( parse_names( teleport_pp ) )
  if pn then
    pn = tonumber( pn )
  else
    pn = 0
  end
  ASSERT(
    level.patrol_path_exists( path ),
    "[%s]: patrol_path %s not found", script_name(), path
  )
  local pp = patrol( path )
  log2(
    "[%s]: teleport %s to %s(%s)", script_name(), sobj:name(), path, pn
  )
  alife():teleport_object(
    sobj.id,
    pp:point( pn ), pp:level_vertex_id( pn ), pp:game_vertex_id( pn )
  )
end


function cleanup_custom_data( sobj )
  local ini = sobj:spawn_ini()
  remove_sects = {}
  for _, k in ipairs({ "logic", "smart_terrain", "smart_terrains" }) do
    if ini:section_exist( k ) then
      table.insert( remove_sects, k )
    end
  end
  if table.getn( remove_sects ) > 0 then
    log2(
      "[%s]: %s: custom_data detected", script_name(), sobj:name()
    )
    log1( sobj.custom_data )
    ini.readonly = false
    for _, k in ipairs( remove_sects ) do
      ini:remove_section( k )
    end
    sobj:save_spawn_ini()
    dsh.clear_smart_terrain_conditions( sobj )
  end
end


function check_npc_name( sect, sobj )
  if not sys_ini:section_exist( sect ) then return true end
  local names = get_string( sect, "dsh_walking_stalkers.names" )
  if not names then return true end
  for _, n in ipairs( parse_names( names ) ) do
    if sobj:name() == n then return true end
  end
  return false
end
