-- -*- mode: lua; coding: windows-1251-dos -*-
-------------------------------------------------------------------------------
--| ogse_relations.script                                                   |--
--| Скриптовая обвязка для очистки отношений                                |--
--| K.D., OGS Evolution Team, 2015                                          |--
--| Ревизия: 14/03/2015                                                     |--
-------------------------------------------------------------------------------

function attach(sm)
  sm:subscribe({ signal = "on_npc_before_hit",  fun = this.on_npc_before_hit  })
  sm:subscribe({ signal = "on_npc_death",       fun = this.on_npc_death       })
  sm:subscribe({ signal = "on_spawn",           fun = this.on_spawn           })
end


local friends_comm = {
  [ "ecolog"  ] = true,
  [ "dolg"    ] = true,
  [ "freedom" ] = true,
  [ "green"   ] = true,
  [ "nebo"    ] = true,
  [ "stalker" ] = true,
  [ "trader"  ] = true,
}

function on_npc_before_hit( obj, hit_data )
  if
    ( not obj:alive() )
    or hit_data.who_id ~= db.actor:id()
    or obj:relation( db.actor ) == game_object.enemy
    or hit_data.power == 0
  then
    return
  end
  local binder = obj:binded_object()
  local t      = binder[ script_name() ]
  if not t then
    t = {}
    binder[ script_name() ] = t
  end
  if t.ff_detected then return end
  t.ff_detected = true
  local gulag = xr_gulag.get_npc_gulag( obj )
  if gulag then
    t.gulag = gulag.name
  end
  t.kamp = xr_kamp.find_npc_kamp( obj )
  local wpn, ammo
  if hit_data.weapon_id then
    wpn = level.object_by_id( hit_data.weapon_id )
    if wpn then
      ammo = dsh.get_cur_wpn_ammo( wpn )
      wpn  = wpn:section()
    end
  end
  log2(
    "[%s]: friendly fire registered: %s, weapon = %s (%s)",
    script_name(), obj:name(), tostring( wpn ), tostring( ammo )
  )
end


local gulags_bad = {
  [ "val_escort"    ] = true,
  [ "val_sacrifice" ] = true
}

function on_npc_death( victim, who )
  if not who then return end
  if who:id() ~= db.actor:id() then return end
  local binder = victim:binded_object()
  local t      = binder[ script_name() ]
  if not ( t and t.ff_detected ) then return end
  if friends_comm[ victim:character_community() ] then
    local timer_name = "dsh_ogse_relations.ff_detected_sms1"
    if not ogse_st_mgr.timer_exists( timer_name ) then
      ogse_st_mgr.start_gtimer( timer_name, 19 * 60 , timer_name )
    end
  end
  if t.gulag and not gulags_bad[ t.gulag ] then
    xr_gulag.setGulagEnemy( t.gulag, db.actor )
  end
  if t.kamp then t.kamp:set_kamp_enemy( db.actor ) end
end


function ff_detected_sms1()
  db.actor:change_character_reputation( -50 )
  local timer_name = "dsh_ogse_relations.ff_detected_sms2"
  if not ogse_st_mgr.timer_exists( timer_name ) then
    ogse_st_mgr.start_gtimer( timer_name, 5 * 3600 + 11 * 60 , timer_name )
  end
  local name, sname = amk_names_lists.get_strings()
  amk.send_tip(
    "ff_detected_sms1_0",
    string.format( "%s %s", name, sname ),  0, 5, "uniq", "news"
  )
  name, sname = amk_names_lists.get_strings()
  amk.send_tip(
    "ff_detected_sms1_1",
    string.format( "%s %s", name, sname ), 15, 5, "uniq", "news"
  )
end


function ff_detected_sms2()
  db.actor:change_character_reputation( -250 )
  local name, sname = amk_names_lists.get_strings()
  amk.send_tip(
    string.format(
      "ff_detected_sms2_0",
      dsh.get_actor_name()
    ),
    string.format( "%s %s", name, sname ),  0, 5, "uniq","news"
  )
  name, sname = amk_names_lists.get_strings()
  amk.send_tip(
    "ff_detected_sms2_1",
    string.format( "%s %s", name, sname ), 15, 5, "uniq", "news"
  )
end


local cache_reputation_idx = {}
local reputation

function get_reputation_idx( rep )
  if not cache_reputation_idx[ rep ] then
    for i = 1, table.getn( reputation ), 2 do
      if i < table.getn( reputation ) then
        if rep < tonumber( reputation[ i + 1 ] ) then
          cache_reputation_idx[ rep ] = i
          break
        end
      else
        cache_reputation_idx[ rep ] = i
        break
      end
    end
  end
  return cache_reputation_idx[ rep ]
end


local max_reputation, max_seen_reputation, max_seen_reputation_idx

function on_spawn()
  local s = get_string( "game_relations", "reputation" )
  ASSERT( s, "'reputation' not found in [game_relations]" )
  reputation = parse_names( s )
  ASSERT(
    table.getn( reputation ) > 2,
    "wrong 'reputation' in [game_relations]: %s", s
  )
  local max = tonumber( reputation[ table.getn( reputation ) - 1 ] )
  ASSERT( max, "wrong 'reputation' in [game_relations]: %s", s )
  if db.actor:character_reputation() > max then
    log2(
      "[%s]: adjust actor's character_reputation(): %s -> %s",
      script_name(), db.actor:character_reputation(), max
    )
    db.actor:change_character_reputation(
      max - db.actor:character_reputation()
    )
  end
  max_reputation = max

  max_seen_reputation = ogse.load_var_safe(
    "dsh_ogse_relations.max_seen_reputation"
  )
  log2(
    "[%s]: load actor's max character_reputation(): %s",
    script_name(), tostring( max_seen_reputation )
  )
  if
    ( not max_seen_reputation )
    or db.actor:character_reputation() > max_seen_reputation
  then
    log2(
      "[%s]: adjust actor's max character_reputation(): %s -> %s",
      script_name(), tostring( max_seen_reputation ),
      db.actor:character_reputation()
    )
    max_seen_reputation = db.actor:character_reputation()
    ogse.save_var(
      "dsh_ogse_relations.max_seen_reputation", max_seen_reputation
    )
  end
  max_seen_reputation_idx = get_reputation_idx( max_seen_reputation )
  log2(
    "[%s]: actor's max character_reputation() index: %s",
    script_name(), max_seen_reputation_idx
  )
end


function has_enough_reputation( use_next_random )
  local idx = get_reputation_idx( db.actor:character_reputation() )
  if idx < max_seen_reputation_idx then return end
  local rep = math.min(
    max_reputation, math.max( 0, db.actor:character_reputation() )
  )
  local k = rep / max_reputation
  if
    k >= 1
    or dsh.get_next_random( "dsh_ogse_relations.has_enough_reputation" ) < k
  then
    return k
  end
end
