-- -*- mode: lua; coding: windows-1251-dos -*-

local teleport_sid = story_ids.level_changer


function attach( sm )
  sm:subscribe({ signal = "on_first_update", fun = this.on_first_update })
  sm:subscribe({ signal = "on_save",         fun = this.on_save         })
  sm:subscribe({ signal = "on_spawn",        fun = this.on_spawn        })
  sm:subscribe({ signal = "on_spawn_another_level", fun = this.on_spawn_another_level })
  -- sm:subscribe({ signal = "on_take",  fun = this.on_take })
  -- sm:subscribe({ signal = "on_take_from_box", fun = this.on_take_from_box })
  sm:subscribe({ signal = "on_use",          fun = this.on_use          })
end


function on_use( obj, sobj )
  if not sobj then return end
  if meceniy_utils.teleporter_use == 0 then return end
  if obj:section() == "hand_teleporter" then
    local curr_lname = level.name()
    local endpoints  = meceniy_intellectual.tabl_changers_by_level
    local dst        = {}
    for lname, v in pairs( endpoints ) do
      if lname ~= curr_lname and dsh.actor_was_here( lname ) then
        table.insert( dst, v )
      end
    end
    local rnd_dst = dst[ get_next_random( 1, table.getn( dst ) ) ]
    teleport_me(
      {
        [ "arts" ] = {
          [ "af_electra_moonlight" ] = 2,
        },
        [ "can_teleport_checks" ] = {
          this.can_teleport_from_this_level,
        },
        [ "dst" ] = {
          [ "pos" ] = rnd_dst.p_dest_pos,
          [ "lv"  ] = rnd_dst.p_dest_lv,
          [ "gv"  ] = rnd_dst.p_dest_gv,
          [ "dir" ] = { 0, 0, 0 },
        },
        [ "randomize_pos" ] = 50,
      }
    )
    return true
  elseif obj:section() == "teleportator" then
    level.start_stop_menu( ui_teleportator.teleportator_menu(), true )
    return true
  elseif spawn_level_changer.teleports[ obj:section() ] then
    use_hand_teleport( obj:section() )
    return true
  end
end


function use_hand_teleport( sect )
  local desc  = spawn_level_changer.teleports[ sect ]
  local goto  = desc.goto_func[
    get_next_random( 1, table.getn( desc.goto_func ) )
  ]
  local place = spawn_level_changer.places[ goto ]
  local t = {
    [ "dst" ] = {
      [ "pos" ] = place.pos,
      [ "lv"  ] = place.lv,
      [ "gv"  ] = place.gv,
      [ "dir" ] = ( place.view or { 0, 0, 0 } ),
    },
  }
  if desc.art then
    t.art = desc.art
  elseif desc.pay then
    t.arts = {
      [ "af_electra_moonlight" ] = 2,
    }
    t.randomize_pos = 50
  end
  if desc.autosave then t.autosave = desc.autosave end
  if not teleport_me( t ) then
    if not desc.keep then
      ogse.spawn_item_in_inv( sect )
    end
  end
end


local teleported = false
function on_spawn()
  teleported = ogse.load_var( "dsh_hand_teleporter.teleport_me", false )
  ogse.delete_var( "dsh_hand_teleporter.teleport_me" )
  db.actor:disable_info_portion( "teleport_started" )
end


function remove_old_teleport()
  local sobj = alife():story_object( teleport_sid )
  if sobj then
    dsh_alife.release( sobj )
    archievements.acv_count_2event(
      "acv_tp", 50, game.translate_string( "acv_tp" ), "acv_tp2", 100, game.translate_string( "acv_tp2" )
    )
  end
  sobj = alife():story_object( story_ids.level_changer_zone )
  if sobj then
    dsh_alife.release( sobj )
  end
end


function on_spawn_another_level()
  remove_old_teleport()
end


function on_first_update()
  local radius = ogse.load_var( "dsh_hand_teleporter.randomize_pos", 0 )
  ogse.delete_var( "dsh_hand_teleporter.randomize_pos" )
  if radius > 0 then
    local pos = dsh.get_random_pos_in_radius( radius )
    if pos then
      db.actor:set_actor_position( pos )
    end
  end
  local enemies = ogse.load_var_safe( "dsh_hand_teleporter.enemies" )
  ogse.delete_var( "dsh_hand_teleporter.enemies" )
  if enemies and table.getn( enemies ) > 0 then
    teleport_enemies_to_me( enemies, 5, 30 )
  end
  if teleported then teleported_actor_effects() end
end


function teleported_actor_effects()
--[=[
  set_actor_power_max( 0.1 )
  ogse_st_mgr.delayed_fun_start( "dsh_hand_teleporter.restore_power_delayed" )
    :set_delay( math.random( 9 ) )
    :init( "dsh_hand_teleporter.restore_power_delayed" )
    :start( true )
--]=]
  local step = 0.4
  db.actor.health     = 0 - math.random() * step
  -- db.actor.psy_health = 0 - math.random() * step
  db.actor.radiation  = math.random() * step
  db.actor.satiety    = 0 - math.random() * step
end


function restore_power_delayed()
    set_actor_power_max( 1 )
end


function on_take( obj, sobj )
  if not sobj then return end
  if obj:section() == "separator" then return end
  spawn_level_changer.on_take_teleporter( obj )
end

function on_take_from_box( box, item, sitem )
  if not sitem then return end
  spawn_level_changer.on_take_teleportator( item )
end


function teleport_me( t )
  level.start_stop_menu( level.main_input_receiver(), true )
  if not can_teleport( t )   then return false end
  if not use_arts( t, true ) then return false end
  if t.autosave and t.autosave ~= level.name() then
    u3_utils.savegame_lc( game.translate_string( "teleport_me_0_0" ), t.autosave )
  end
  if not use_arts( t ) then return false end
  ogse.save_var( "dsh_hand_teleporter.teleport_me", true )
  if t.randomize_pos then
    ogse.save_var( "dsh_hand_teleporter.randomize_pos", t.randomize_pos )
  end
  db.actor:give_info_portion( "teleport_started" )
  db.actor:disable_info_portion( "no_gravigun" )
  teleport_actor(
    t.dst.pos, t.dst.lv, t.dst.gv, ( t.dst.dir or { 0, 0, 0 } )
  )
  return true
end


function can_teleport( t )
  if not can_teleport_in_this_situation() then return false end
  if t.can_teleport_checks then
    for _, f in ipairs( t.can_teleport_checks ) do
      if not f() then return false end
    end
  end
  return true
end


function can_teleport_in_this_situation()
  if
    has_alife_info( "no_teleport_near_heli_btr" )
    or (
      has_alife_info( "kod_vveden_verno" )
      and not has_alife_info( "dead_city_atpeshka" )
    )
    or db.actor:has_info( "volna_goodwill" )
  then
    dsh.say_blin()
    news_manager.send_tip(
      db.actor,
      "can_teleport_in_this_situation",
      nil, "nano", 20000
    )
    return false
  end
  return true
end


function can_teleport_from_this_level()
  local endpoints = meceniy_intellectual.tabl_changers_by_level
  if not endpoints[ level.name() ] then
    dsh.say_blin()
    local levels = {}
    for lname, _ in pairs( endpoints ) do
      table.insert( levels, game.translate_string( lname ) )
    end
    news_manager.send_tip(
      db.actor,
      string.format(
        game.translate_string( "can_teleport_from_this_level" ),
        table.concat( levels, ", " )
      ),
      nil, "nano", 10000
    )
    return false
  end
  return true
end


function use_arts( t, test )
  local need_arts = 0
  local arts      = {}
  if t.art then
    arts[ t.art ] = 1
    need_arts     = need_arts + 1
  end
  if t.arts then
    for k, n in pairs( t.arts ) do
      arts[ k ] = n
      need_arts = need_arts + n
    end
  end
  if need_arts == 0 then return true end
  local use_arts = {}
  for k, n in pairs( arts ) do
    local found = 0
    local prop  = amk_utils.get_item_props( k )
    for _, aka in ipairs( prop.aka ) do
      local objs = inventory.on_belt_obj( aka )
      if objs then
        for _, obj in ipairs( objs ) do
          if dsh.is_zone_bio_art( obj ) then
            table.insert( use_arts, obj )
            found = found + 1
            if found == n then break end
          end
        end
        if found == n then break end
      end
    end
  end
  if table.getn( use_arts ) == need_arts then
    if not test then
      for _, obj in ipairs( use_arts ) do
        ogse.remove_item_from_inventory( obj )
      end
    end
    return true
  end
  dsh.say_blin()
  news_manager.send_tip(
    db.actor,
    "use_arts_cant",
    nil, "nano", 5000
  )
  return false
end


function teleport_actor( pos, lvid, gvid, dir )
  level.add_pp_effector( "teleport.ppe", 2006, false )
  if type( pos ) == "table" then
    pos = vector():set( unpack( pos ) )
  end
  if not dir then
    dir = vector():set( 0, 0, 0 )
  elseif type( dir ) == "table" then
    dir = vector():set( unpack( dir ) )
  end
  dsh.timeout( 1000, function()
    level.change_level( gvid, lvid, pos, dir )
  end )
end


function create_level_changer( sid, position, lvid, gvid, spot, hint, dest_position, dest_lvid, dest_gvid, dest_dir_v, mode, shapes )
  if type( position ) == "table" then
    position = vector():set( unpack( position ) )
  end
  local sobj = alife():create( "level_changer", position, lvid, gvid )
  ASSERT( sobj, "create_level_changer: failed to create level changer" )

  if spot ~= nil and hint ~= nil then
    level.map_add_object_spot_ser( sobj.id, spot, hint )
  end

  local initial_packet = get_netpk( sobj, 1 )
  local table_lc       = initial_packet:get()

  if type( dest_position ) == "table" then
    dest_position = vector():set( unpack( dest_position ) )
  end
  if type( dest_dir_v ) == "table" then
    dest_dir_v = vector():set( unpack( dest_dir_v ) )
  end

  table_lc.dest_position   = dest_position
  table_lc.dest_level_vertex_id = dest_lvid
  table_lc.dest_game_vertex_id  = dest_gvid
  table_lc.dest_direction  = dest_dir_v
  table_lc.dest_level_name = level_system_name_by_gvid( gvid )
  table_lc.silent_mode     = mode
  table_lc.restrictor_type = 3

  if type( shapes ) == "number" then
    table_lc.shapes:addSphere( shapes )
  elseif type( shapes ) == "table" then
    for i, shp in ipairs( shapes ) do
      if shp.shtype == 0 then --/ sphere
        table_lc.shapes:addSphere(
          shp.radius, vector():set( unpack( shp.center ) )
        )
      else --/ box
        table_lc.shapes:addBox(
          matrix():set(
            vector():set( unpack( shp.box[ 1 ] ) ),
            vector():set( unpack( shp.box[ 2 ] ) ),
            vector():set( unpack( shp.box[ 3 ] ) ),
            vector():set( unpack( shp.offset ) )
          )
        )
      end
    end
  else
    abort( "create_level_changer: unknown shape type" )
  end

  initial_packet:set( table_lc )
  alife():assign_story_id( sobj.id, sid )

  return alife():object( sobj.id )
end


function make_enemy_free( sobj )
  local pk = get_netpk( sobj, 1 )
  ASSERT( ( pk and pk:isOk() ), "can't read netpacket of %s", sobj:name() )
  local data = pk:get()
  data.base_in_restrictors  = ""
  data.base_out_restrictors = ""
  data.custom_data:setTable( {} )
  data.story_id = -1
  pk:set( data )
  smart_terrain.unregister_npc( sobj )
  dsh.clear_smart_terrain_conditions( sobj )
  sobj:brain():can_choose_alife_tasks( false )
end


function teleport_enemies_to_me( enemies, min, radius )
  for _, t in ipairs( enemies ) do
    local id, dist = unpack( t )
    if dist > 0 then
      dsh.timeout(
        dist / 10 * 1000,
        function( id, pos, lvid )
          local sobj = alife():object( id )
          if sobj and sobj:alive() then
            make_enemy_free( sobj )
            alife():teleport_object(
              sobj.id, pos, lvid, db.actor:game_vertex_id()
            )
          end
        end,
        id, db.actor:position(), db.actor:level_vertex_id()
      )
    else
      local sobj = alife():object( id )
      if sobj then
        local pos, lvid = dsh.get_random_pos_in_radius( radius, min )
        if pos then
          make_enemy_free( sobj )
          sobj:brain():can_choose_alife_tasks( false )
          alife():teleport_object(
            id, pos, lvid, cross_table():vertex( lvid ):game_vertex_id()
          )
        end
      end
    end
  end
end


function get_enemies_around( radius, check_see )
  local enemies = {}
  for id in pairs( db.creature ) do
    local obj = level.object_by_id( id )
    if
      obj and obj:alive()
      and not string.find( obj:section(), "rat_", 1, true )
    then
      local dist = obj:position():distance_to( db.actor:position() )
      if
        obj:is_relation_enemy( db.actor )
        and ( not ogse.is_quest_npc( obj ) )
        and (
          (
            obj:best_enemy() and obj:best_enemy():is_actor()
            and ( ( not check_see ) or obj:see( db.actor ) )
          )
          or dist <= radius
        )
        and xrs_battle_ai.check_is_enemy( obj, db.actor )
        and not xr_wounded.is_wounded( obj )
      then
        local sobj = alife():object( obj:id() )
        if sobj then
          smart_terrain.unregister_npc( sobj )
          sobj:brain():can_choose_alife_tasks( false )
          dsh_respawn.on_release_npc( sobj.id )
          table.insert(
            enemies,
            {
              [ "dist" ] = dist,
              [ "id"   ] = sobj.id,
            }
          )
        end
      end
    end
  end
  return enemies
end


function get_next_random( ... )
  return dsh.get_next_random( "dsh_hand_teleporter.rnd", ... )
end


function on_save()
  local enemies
  if db.actor:has_info( "teleport_started" ) then
    enemies = get_enemies_around( 20 )
    for _, e in ipairs( enemies ) do
      e.dist = 0
    end
  elseif utils.level_changing() then
    enemies = get_enemies_around( 10, true )
  end
  if enemies and table.getn( enemies ) > 0 then
    local t = {}
    for _, e in ipairs( enemies ) do
      table.insert( t, { e.id, e.dist } )
    end
    ogse.save_var(
      "dsh_hand_teleporter.enemies", t, "array_template", { "u16", "u16" }
    )
  end
end
