-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm )
  sm:subscribe({ signal = "inv_drag_drop", fun = this.inv_drag_drop })
  -- sm:subscribe({ signal = "on_use", fun = this.on_use })
end


function on_use( obj, sobj )
  if not sobj then return end
  local sect = obj:section()
  if sect == "repair_item_weapon" or sect == "repair_item_outfit" then
    remkit_main.call_menu_repair_kit( obj )
    return true
  end
end


local min_repairable_cond = 0.85

function inv_drag_drop( obj, me )
  local sect = obj:section()
  if
    not (
      (
        sect == "repair_item_weapon" and me:is_weapon_magazined()
        and dsh.is_weapon( me )
      )
      or ( sect == "repair_item_outfit" and me:is_outfit() )
    )
  then
    return
  end
  if me:condition() > 0.99 then
    ogse.autohiding_msg( game.translate_string( "inv_dd_rep_dont_need" ), 1500 )
  elseif me:condition() < 0.2 then
    ogse.autohiding_msg( game.translate_string( "inv_dd_rep_cant" ), 1500 )
  elseif me:condition() < min_repairable_cond then
    ogse.autohiding_msg( game.translate_string( "inv_dd_rep_cant_need_trader" ), 1500 )
  else
    if me:condition() < 0.95 then
      level.start_stop_menu( repair_dialog( me, obj ), true )
    else
      dsh_hud_fx.run_fx_on_update(
        sect, sect,
        {
          {
            [ "func" ] = function()
              ogse.remove_item_from_inventory( obj )
              local cond_inc = get_float(
                me:section(), "dsh_remkit.cond_inc", 0.05
              )
              local new_cond = math.min( 1, me:condition() + cond_inc )
              dsh.set_condition( me, new_cond )
            end,
          },
        },
        {
          [ "obj" ] = me,
        }
      )
    end
  end
  return true
end


class "repair_dialog" ( dsh_ui_simple_craft.ui_simple_craft )
function repair_dialog:__init( item, rem_obj )
  super( "ui_dsh_remkit.xml", item )
  self.rem_obj = rem_obj
end


local min_suitable_cond = 0.3

function repair_dialog:can_include_into_list( item )
  return
    item:id() ~= self.item:id() and db.actor:is_in_ruck( item )
    and (
      (
        self.item:is_weapon_magazined()
        and item:is_weapon_magazined()
        and dsh.is_weapon( item )
      )
      or ( self.item:is_outfit() and item:is_outfit() )
    )
    and item:condition() > min_suitable_cond
    and not watcher_act.do_not_touch( item )
end


function repair_dialog:calc_shans_bar_height( item, destr_item )
  local k = math.min(
    0.9,
    math.max( 0.01, item:condition() - min_repairable_cond ) / 0.1
  )
  local b = 0
  local d = destr_item:condition() - min_suitable_cond
  if d > 0 then
    b = 0.1 * ( d / ( 1 - min_suitable_cond ) )
  end
  return ( k + b ) * 100
end


function repair_dialog:do_craft( item )
  self:on_quit()
  local sect  = self.rem_obj:section()
  local shans = self:calc_shans_bar_height( self.item, item )
  dsh_hud_fx.run_fx(
    sect, sect,
    {
      {
        [ "func" ] = function()
          ogse.remove_item_from_inventory( item )
          ogse.remove_item_from_inventory( self.rem_obj )
          if shans < 100 then
            local rnd = dsh.get_next_random(
              "dsh_remkit.do_craft." .. self.rem_obj:section(), 100
            )
            if rnd > shans then
              dsh.say_blin()
              return
            end
          end
          local cond_inc = get_float(
            self.item:section(), "dsh_remkit.cond_inc2", 0.1
          )
          self.item:set_condition(
            math.min( self.item:condition() + cond_inc, 1 )
          )
        end,
      },
    },
    {
      [ "obj" ] = self.item,
    }
  )
end
