-- -*- mode: lua; coding: windows-1251-dos -*-
--     Лечим нерадивых товарищей...
-- ver: 2.0
--     автор: xStream
--     TODO:

local excluded_npcs = {
  -- фотография в X-16
  [ "foto_monolitovets"          ] = true,
  -- фотография Монолита в Саркофаге
  [ "nevid_monolit"              ] = true,
  [ "esc_fox"                    ] = true,
  [ "esc_vagon_wounded"          ] = true,
  [ "gar_bandit_stroyka3"        ] = true,
  [ "gar_wounded_bandit"         ] = true,
  [ "val_sos_wounded"            ] = {
    [ "until_info" ] = "val_sos_got_medkit",
  },
  [ "val_escort_bandit_halfdead" ] = {
    [ "until_info" ] = "val_bandit_talk",
  },
  [ "nebo_kurier"                ] = true,
  [ "scromnyi"                   ] = true,
  [ "forest_wound"               ] = true,
  [ "dead_mono_labirint"         ] = true,
  [ "labirint_monolit_shahter"   ] = true,
  [ "muha_soldat_ranen"          ] = true,
  [ "ecolog_wound_bunker"        ] = true,
  -- фотография на АС
  [ "military_fotomuzhik"        ] = true,
  [ "milit_zapas_fotomuzhik"     ] = true,
  -- фотография на Кордоне
  [ "esc_foto_muzhik"            ] = true,
  [ "zapasnoy_foto_muzhik"       ] = true,
  [ "mil_stalker0012"            ] = true,
  [ "yantar_ecolog_general"      ] = true,
  -- Круглов, который бежит лечить Грома, но в другую сторону.
  [ "yan_scientist_help"         ] = true,
  [ "brat_luis"                  ] = true,
  [ "grom_npc"                   ] = true,
  -- бандиты Юрика (profile)
  [ "gar_bandit_dm"              ] = true,

  [ "arena_enemy"                ] = true,
  [ "trader"                     ] = true,
  [ "zombied"                    ] = true,
}

local bandages = { "bandage", }
local medkits  = xr_wounded.medkits

local friends_r = 100
local neutral_r = 100


local wounded   = {}
local has_medic = {}

evid_medic       = 18680
evid_self_medic  = evid_medic + 1

actid_medic      = evid_medic
actid_self_medic = actid_medic + 1

local anims = {
  {
    a = "norm_torso_12_draw_0",
    t = 500
  },
  {
    a = "norm_torso_12_attack_0",
    t = 3600
  },
  {
    a = "norm_torso_12_holster_0",
    t = 300
  },
}


function attach( sm )
  sm:subscribe({ signal = "on_npc_death", fun = this.on_death     })
  sm:subscribe({ signal = "on_npc_net_destroy", fun = this.on_npc_net_destroy })
  sm:subscribe({ signal = "on_npc_spawn", fun = this.on_npc_spawn })
  sm:subscribe({ signal = "on_spawn",     fun = this.on_spawn     })
end


function on_spawn()
  dsh.exec_on_update( function()
    ogse_signals.get_mgr():subscribe({
      signal = "on_take", fun = this.pickup,
      script_name = "xrs_medic.pickup",
    })
  end )
end


function is_excluded_npc( npc )
  if rx_utils.IsTrader( npc ) then return true end
  local d = excluded_npcs[ npc:name() ]
    or excluded_npcs[ npc:profile_name() ]
    or excluded_npcs[ npc:character_community() ]
  if d then
    if type( d ) == "table" then
      if d.until_info then
        return db.actor:dont_has_info( d.until_info )
      end
    end
    return true
  end
  return false
end


function on_npc_spawn( obj, binder )
  has_medic[ obj:id() ] = nil
  wounded[   obj:id() ] = nil
  if not obj:alive() then return end
  if is_excluded_npc( obj ) then return end
  local s = {
    {
      signal = "on_npc_update." .. obj:id(), fun = this.npc_update_wounded,
      script_name = "xrs_medic.npc_update_wounded",
    },
    {
      signal = "on_npc_update." .. obj:id(), fun = this.npc_update_medkits,
      script_name = "xrs_medic.npc_update_medkits",
    },
  }
  binder[ "xrs_medic.subscribed" ] = s
  local sm = ogse_signals.get_mgr()
  for _, item in ipairs( s ) do
    sm:subscribe( item )
  end
end


function on_death( obj )
  local binder     = obj:binded_object()
  local subscribed = binder[ "xrs_medic.subscribed" ]
  if subscribed then
    local sm = ogse_signals.get_mgr()
    for _, item in ipairs( subscribed ) do
      sm:unsubscribe( item )
    end
    binder[ "xrs_medic.subscribed" ] = nil
  end
  death_callback( obj, true )
end


function on_npc_net_destroy( obj )
  death_callback( obj )
end


class "evaluator_medic" ( property_evaluator )
function evaluator_medic:__init( name, storage ) super( nil, name )
  self.a = storage
  self.next_check_time         = time_global() + 5000
  self.a.next_medic_change_pos = 0
end


function evaluator_medic:evaluate()
  if
    xr_wounded.is_wounded( self.object ) or self.object:best_enemy()
    or xrs_battle_ai.in_combat[ self.object:id() ]
  then
    return false
  end

  local npc = self.object
  if not npc:alive() then return false end
  if wounded[ npc:id() ] then return false end

  if not self.a.target_wounded then
    if ( self.next_check_time or 0 ) > time_global() then return false end
    self.next_check_time = time_global() + 5000
    local wounded_guy
    for k, v in pairs( wounded ) do
      if v and not has_medic[ k ] then
        local obj = get_npc( k )
        if
          obj and obj:alive()
          and npc:accessible( obj:level_vertex_id() )
          and (
            (
              npc:relation( obj ) == game_object.friend
              and npc:position():distance_to( obj:position() ) < friends_r
            )
            or (
              npc:relation( obj ) == game_object.neutral
              and npc:position():distance_to( obj:position() ) < neutral_r
            )
          )
          and ( npc:see( obj ) or self:check_seen( obj:id() ) )
        then
          wounded_guy = k
          break
        end
      end
    end
    self:clean_seen()
    if not wounded_guy then return false end
    local has_medkit = false
    for _, sect in ipairs( medkits ) do
      local obj = npc:object( sect )
      if obj and alife():object( obj:id() ) then
        has_medkit = true
        break
      end
    end
    if not has_medkit then
      -- если с лекарствами всё хреново, а рядом раненый лежит стонет
      ogse.spawn_item_in_inv( medkits[ 1 ], npc )
    end
    self.a.target_wounded = wounded_guy
    if
      self.a.next_medic_change_pos
      and self.a.next_medic_change_pos < time_global()
    then
      self.a.from_point = npc:position()
    end
    has_medic[ wounded_guy ] = npc:id()
    ogse_debug.add_active_eval( self.object, script_name(), "medic" )
    return true

  else                          -- if not self.a.target_wounded
    if
      ( not wounded[ self.a.target_wounded ]  )
      or (
        get_npc( self.a.target_wounded )
        and (
          ( not get_npc( self.a.target_wounded ):alive() )
          or not (
            get_npc( self.a.target_wounded ):wounded()
            or get_npc( self.a.target_wounded ):critically_wounded()
          )
        )
      )
      or (
        has_medic[ self.a.target_wounded ]
        and has_medic[ self.a.target_wounded ] ~= npc:id()
      )
    then
      self.a.target_wounded = nil
      self.a.from_point     = nil
      return false
    end
    ogse_debug.add_active_eval( self.object, script_name(), "medic_2" )
    return true
  end
end


function evaluator_medic:check_seen( id )
  if not self.seen then
    self.seen = {}
    for o in self.object:memory_visible_objects() do
      local obj = o:object()
      if obj and IsStalker( obj ) then
        self.seen[ obj:id() ] = true
      end
    end
    for o in self.object:memory_sound_objects() do
      local obj = o:object()
      if obj and IsStalker( obj ) then
        self.seen[ obj:id() ] = true
      end
    end
  end
  return self.seen[ id ]
end


function evaluator_medic:clean_seen()
  self.seen = nil
end


class "evaluator_self_medic" ( property_evaluator )
function evaluator_self_medic:__init( name, storage ) super( nil, name )
  self.a = storage
  self.next_check_time = time_global() + 5000
end


function evaluator_self_medic:evaluate()
  local npc = self.object
  if has_medic[ npc:id() ] then
    self.a.self_healing = false
    return false
  elseif npc:best_enemy() or xrs_battle_ai.in_combat[ npc:id() ] then
    self.a.self_healing = false
    return false
  end
  if self.a.self_healing then return true end
  if npc.health > 0.9 then
    self.a.self_healing = false
    return false
  end
  if ( self.next_check_time or 0 ) > time_global() then return false end
  self.next_check_time = time_global() + 5000
  local has_medkit = false
  for _, sect in ipairs( medkits ) do
    local obj = npc:object( sect )
    if obj and alife():object( obj:id() ) then
      has_medkit = true
      break
    end
  end
  if not has_medkit then
    for _, sect in ipairs( bandages ) do
      local obj = npc:object( sect )
      if obj and alife():object( obj:id() ) then
        has_medkit = true
        break
      end
    end
  end
  if not ( has_medkit and npc:object( "yad" ) ) then return false end
  self.a.self_healing = true
  return true
end


class "action_medic" ( action_base )
function action_medic:__init( npc, action_name, storage ) super( nil, action_name )
  self.a = storage
  self.a.tgt_vertex = nil
end


function action_medic:initialize()
  action_base.initialize( self )
  local npc = self.object
  npc:set_item( object.idle, nil )
  xr_sound.set_sound( npc, nil )
  stop_play_sound( npc )
  if self.a.target_wounded then
    local wounded_npc = get_npc( self.a.target_wounded )
    if wounded_npc and wounded_npc:alive() then
      local be = xrs_battle_ai.get_target( wounded_npc )
        or wounded_npc:best_enemy()
      if xrs_battle_ai.is_danger_corpse( npc, be ) then
        xrs_battle_ai.register_as_target( npc, be, true )
      end
    end
  end
end


function action_medic:execute()
  action_base.execute( self )
  local npc = self.object

  local wounded_npc
  if self.a.target_wounded then
    wounded_npc = get_npc( self.a.target_wounded )
    if
      not (
        wounded_npc and wounded_npc:alive()
        and ( wounded_npc:wounded() or wounded_npc:critically_wounded() )
      )
    then
      wounded_npc = nil
    end
    if not wounded_npc then
      has_medic[ self.a.target_wounded ] = nil
    end
  end
  if not wounded_npc then
    self.a.target_wounded = nil
    self.a.from_point     = nil
    npc:clear_animations()
    return false
  end

  if not self.a.tgt_vertex then
    local wounded_vtx = wounded_npc:level_vertex_id()
    if npc:accessible( wounded_vtx ) then
      self.a.tgt_vertex = wounded_vtx
    else
      local diff  = wounded_npc:bone_position( "bip01_spine" )
        :sub( wounded_npc:position() )
      local lengt     = diff:magnitude() * 2.5
      local pos       = vector():mad( wounded_npc:position(), diff, lengt )
      local test_lvid = level.vertex_id_by_pos( pos )
      if not level.valid_vertex_id( test_lvid ) then
        test_lvid = level.vertex_id_by_pos( wounded_vtx, pos )
      end
      if not level.valid_vertex_id( test_lvid ) then
        test_lvid = wounded_vtx
      end
      if not npc:accessible( test_lvid ) then
        test_lvid = npc:accessible_nearest(
          level.vertex_position( test_lvid ), vector():set( 0, 0, 0 )
        )
      end
      self.a.tgt_vertex = test_lvid
    end
  end

  if
    ( self.a.tgt_vertex and npc:level_vertex_id() ~= self.a.tgt_vertex )
    and npc:position():distance_to( wounded_npc:position() ) > 1.2
  then
    npc:set_detail_path_type( move.curve )
    npc:set_path_type( game_object.level_path )
    npc:set_desired_direction()
    npc:set_desired_position( wounded_npc:position() )
    if self.a.tgt_vertex then
      utils.send_to_nearest_accessible_vertex( npc, self.a.tgt_vertex )
    else
      utils.send_to_nearest_accessible_vertex(
        npc, wounded_npc:level_vertex_id()
      )
    end
    state_mgr.set_state( npc, "run" )
  elseif
    npc:position():distance_to( wounded_npc:position() ) <= 1.2
    or ( self.a.tgt_vertex and npc:level_vertex_id() == self.a.tgt_vertex )
  then
    wounded_npc:disable_talk()
    if ( not self.step1 ) and npc:animation_count() == 0 then
      utils.send_to_nearest_accessible_vertex( npc, npc:level_vertex_id() )
      npc:set_desired_position()
      npc:clear_animations()
      npc:set_movement_type( move.stand )
      state_mgr.set_state(
        npc, "dynamite", nil, nil, { look_object = wounded_npc },
        { animation = true }
      )
      self.step1 = time_global() + 3000
      for _, sect in ipairs( medkits ) do
        local obj = npc:object( sect )
        if obj and alife():object( obj:id() ) then
          -- npc:transfer_item( obj, wounded_npc )
          ogse.remove_item_from_inventory( obj, npc )
          break
        end
      end
      local snd = "characters_voice\\human_01\\" .. npc:character_community()
        .. "\\help\\wounded\\medkit_" .. math.random( 1, 3 )
      snd = xr_sound.get_safe_sound_object( snd )
      if snd then
        snd:play_no_feedback( npc, sound_object.s3d, 0, npc:position(), 1.0 )
      end
    end
    if self.step1 and ( not self.step2 ) and self.step1 < time_global() then
      npc:clear_animations()
      local dist_to_actor = wounded_npc:position()
        :distance_to( db.actor:position() )
      if dist_to_actor <= 3 then
        db.actor:stop_talk()
        wounded_npc:stop_talk()
      end
      xr_wounded.unlock_medkit( wounded_npc )
      if wounded_npc:relation( npc ) ~= game_object.enemy then
        wounded_npc:set_relation( game_object.friend, npc )
      end
      npc:change_character_reputation( 10 )
      self.step2=time_global() + 2000
      wounded_npc:enable_talk()
    end
    if self.step1 and self.step2 and self.step2 < time_global() then
      xr_logic.initialize_obj(
        wounded_npc, db.storage[ wounded_npc:id() ], true, db.actor,
        modules.stype_stalker
      )
      has_medic[ self.a.target_wounded ] = nil
      self.a.target_wounded = nil
      self.a.from_point     = nil
    end
  end
end


function action_medic:finalize()
  action_base.finalize( self )
  self.a.next_medic_change_pos = time_global() + 30000
  self.a.tgt_vertex = nil
end


class "action_self_medic" ( action_base )
function action_self_medic:__init( npc, action_name, storage ) super( nil, action_name )
  self.a = storage
end


function action_self_medic:initialize()
  action_base.initialize( self )

  local npc        = self.object
  local has_medkit = false
  for _, sect in ipairs( medkits ) do
    local obj = npc:object( sect )
    if obj and alife():object( obj:id() ) then
      has_medkit = true
      break
    end
  end
  if not has_medkit then
    for _, sect in ipairs( bandages ) do
      local obj = npc:object( sect )
      if obj and alife():object( obj:id() ) then
        has_medkit = true
        break
      end
    end
  end
  if npc.health >= 1 or not has_medkit then
    self.a.self_healing = false
    return
  end

  npc:set_item( object.idle, nil )
  npc:set_movement_type( move.stand )
  npc:set_desired_position()
  npc:set_desired_direction()
  utils.send_to_nearest_accessible_vertex( npc, npc:level_vertex_id() )
  npc:set_movement_type( move.stand )
  npc:set_body_state( move.standing )
  state_mgr.set_state( npc, "idle", nil, nil, nil, { animation = true } )
  self.dir = npc:direction()
  xr_sound.set_sound( npc, nil )
  stop_play_sound( npc )
end


function action_self_medic:execute()
  action_base.execute( self )

  local npc = self.object
  local has_medkit
  for _, sect in ipairs( medkits ) do
    has_medkit = npc:object( sect )
    if has_medkit and alife():object( has_medkit:id() ) then
      break
    else
      has_medkit = nil
    end
  end
  if not has_medkit then
    for _, sect in ipairs( bandages ) do
      has_medkit = npc:object( sect )
      if has_medkit and alife():object( has_medkit:id() ) then
        break
      else
        has_medkit = nil
      end
    end
  end

  if ( not self.allow_empty ) and not has_medkit then
    self.a.self_healing = false
    return
  end

  if not self.ready_state then
    if xrs_battle_ai.is_not_ready_state( npc ) then return end
    if npc:active_item() then
      npc:set_item( object.idle, nil )
      if self.waiting_item_idle and self.waiting_item_idle > time_global() then
        return
      elseif not self.waiting_item_idle then
        self.waiting_item_idle = time_global() + 5000
        return
      end
    end
    self.ready_state = true
    self.waiting_item_idle = nil
  end

  if ( not self.initialized ) and state_mgr.get_state( npc ) == "idle" then
    if npc:animation_count() == 0 then
      local yad = npc:object( "yad" )
      if yad then
        yad:enable_attachable_item( true )
      end
      npc:clear_animations()
      npc:add_animation( "idle_0_to_sit_2" )
      npc:add_animation( "vodka_3" )
      npc:add_animation( "sit_2_to_idle_0" )
      self.initialized = true
      self.end_time    = time_global() + 5000
    end
    return
  else
    npc:set_item( object.idle, nil )
    local yad = npc:object( "yad" )
    if yad then
      yad:enable_attachable_item( true )
    end
  end

  if self.end_time and self.end_time < time_global() then
    local yad = npc:object( "yad" )
    if yad then yad:enable_attachable_item( false ) end
    if has_medkit then
      if xr_wounded.is_wounded( npc ) then
        xr_wounded.unlock_medkit( npc )
      else
        -- npc:eat( has_medkit )
        npc:heal_wounds( 1 )
        npc.health = 1
        ogse.remove_item_from_inventory( has_medkit, npc )
      end
    end
    self.allow_empty = true
    self.end_time       = nil
    self.end_time_total = time_global() + 2000
    state_mgr.set_state( npc, "idle", nil, nil, nil, { animation = true } )
    return
  end
  if self.end_time_total and self.end_time_total < time_global() then
    self.a.self_healing = false
  end
end


function action_self_medic:finalize()
  action_base.finalize( self )
  self.a.self_healing = false
  local npc = self.object
  local yad = npc:object( "yad" )
  if yad then yad:enable_attachable_item( false ) end
  self.allow_empty = nil
  self.end_time    = nil
  self.end_time_total = nil
  self.initialized = nil
  self.ready_state = nil
  npc:set_movement_type( move.stand )
  npc:set_body_state( move.standing )
  state_mgr.set_state( npc, "idle", nil, nil, nil, { animation = true } )
end


function add_to_binder( object, ini, scheme, section, storage )
  local operators  = {
    [ "medic"      ] = actid_medic,
    [ "self_medic" ] = actid_self_medic,
  }
  local properties = {
    [ "medic"      ] = evid_medic,
    [ "self_medic" ] = evid_self_medic,
  }

  local manager = object:motivation_action_manager()
  if is_excluded_npc( object ) then
    manager:add_evaluator( properties.medic, property_evaluator_const( false ) )
    manager:add_evaluator(
      properties.self_medic, property_evaluator_const( false )
    )
  else
    manager:add_evaluator(
      properties.medic, evaluator_medic( "medic", storage )
    )
    manager:add_evaluator(
      properties.self_medic, evaluator_self_medic( "self_medic", storage )
    )
  end

  local action = action_medic( object, "medic", storage )
  action:add_precondition( world_property( stalker_ids.property_alive, true  ) )
  action:add_precondition( world_property( stalker_ids.property_enemy, false ) )
  action:add_precondition(
    world_property( xr_evaluators_id.sidor_wounded_base, false )
  )
  action:add_precondition(
    world_property( xrs_battle_ai.evid_altcombat, false )
  )
  action:add_precondition( world_property( properties.self_medic, false ) )
  action:add_precondition( world_property( properties.medic, true ) )
  action:add_effect( world_property( properties.medic, false ) )
  manager:add_action( operators.medic, action )

  action = action_self_medic( object, "self_medic", storage )
  action:add_precondition( world_property( stalker_ids.property_alive, true  ) )
  action:add_precondition( world_property( stalker_ids.property_enemy, false ) )
  action:add_precondition(
    world_property( xrs_battle_ai.evid_altcombat, false )
  )
  action:add_precondition(
    world_property( xr_evaluators_id.sidor_wounded_base, false )
  )
  action:add_precondition( world_property( properties.self_medic, true ) )
  action:add_precondition( world_property( properties.medic, false ) )
  action:add_effect( world_property( properties.self_medic, false ) )
  manager:add_action( operators.self_medic, action )

  action = manager:action( xr_actions_id.alife )
  action:add_precondition( world_property( properties.medic, false ) )
  action:add_precondition( world_property( properties.self_medic, false ) )

  state_mgr.add_to_idle_preconditions(
    manager, { properties.medic, properties.self_medic }
  )
end


function set_scheme( npc, ini, scheme, section )
  local st = xr_logic.assign_storage_and_bind( npc, ini, scheme, section )
end


function disable_scheme( npc, scheme )
  local st = db.storage[ npc:id() ][ scheme ]
  if st then st.enabled = false end
end


function get_npc( id )
  return level.object_by_id( id )
end


function death_callback( npc, cleanup )
  has_medic[ npc:id() ] = nil
  wounded[ npc:id()   ] = nil
  if not cleanup then return end
  local remove_sects = {
    [ "yad" ] = true,
  }
  for _, sect in pairs( medkits  ) do
    remove_sects[ sect ] = true
  end
  for _, sect in pairs( bandages ) do
    remove_sects[ sect ] = true
  end
  local remove_medkits = {}
  npc:iterate_inventory(
    function ( dummy, item )
      if not alife():object( item:id() ) then return end
      if remove_sects[ item:section() ] then
        table.insert( remove_medkits, item:id() )
      end
    end, npc
  )
  for _, v in ipairs( remove_medkits ) do
    local sobj = alife():object( v )
    if sobj then
      alife():release( sobj, true )
    end
  end
end


function add_wounded( npc )
  if wounded[ npc:id() ] == nil then
    wounded[ npc:id()   ] = not is_excluded_npc( npc )
    has_medic[ npc:id() ] = nil
  end
end


function remove_wounded( npc )
  wounded[ npc:id() ] = nil
end


function npc_update_wounded( npc )
  ogse_signals.get_mgr():reschedule( 5000 )
  if xr_wounded.can_use_medkit( npc ) then return end
  if npc:critically_wounded() or npc:wounded() then
    add_wounded( npc )
  else
    remove_wounded( npc )
  end
  if not npc:object( "yad" ) then
    ogse.spawn_item_in_inv( "yad", npc )
  end
end


function npc_update_medkits( npc )
  ogse_signals.get_mgr():reschedule( 300000 )
  local has_medkit
  for _, sect in ipairs( medkits ) do
    has_medkit = npc:object( sect )
    if has_medkit and alife():object( has_medkit:id() ) then
      break
    else
      has_medkit = nil
    end
  end
  if not has_medkit then
    if math.random() > 0.2 then
      ogse.spawn_item_in_inv(
        medkits[ math.random( table.getn( medkits ) ) ], npc
      )
    end
  end
  for _, sect in ipairs( bandages ) do
    has_medkit = npc:object( sect )
    if has_medkit and alife():object( has_medkit:id() ) then
      break
    else
      has_medkit = nil
    end
  end
  if not has_medkit then
    if math.random() > 0.05 then
      ogse.spawn_item_in_inv(
        bandages[ math.random( table.getn( bandages ) ) ], npc
      )
    end
  end
end


function pickup( obj, sobj )
  if obj:section() == "yad" then
    alife():release( sobj, true )
    return true
  end
end
