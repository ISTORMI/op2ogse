-- -*- mode: lua; coding: windows-1251-dos -*-
--
-- Изменения script_version:
--   3 - сохранение поля job_online
--   5 - сохранение поля was_in_smart_terrain
--   6 - сохранение поля death_droped

stalkers = {}


class "se_stalker"  (cse_alife_human_stalker)
--------------------
function se_stalker:__init (section) super (section)
  self.ini = nil
  self.ini_initialized = false

  self.spawner_present = false

  self.smart_terrain_conditions     = nil
  self.smart_terrain_conditions_cnt = 0
  self.smart_terrain_conditions_initialized = false

  -- этот флаг берётся из работы смарта
  -- true     = всегда в онлайне
  -- false    = всегда в офлайне
  -- condlist = условие, которое отпределяет true или false
  -- nil      = смарту всё равно
  self.job_online          = nil
  self.job_online_condlist = nil

  -- посещал ли сталкер хоть один smart_terrain
  self.was_in_smart_terrain = false

  self.death_droped = false --'Генерил ли персонаж выпадаемые предметы или нет.

  --' Test for dima
  self.dont_spawn_online = false

  --' Вызывался ли генератор ссылок на тайники.
  self.treasure_processed = false

  --' Флаг смерти в оффлайне
  self.offline_dead = 0

  self.check_distance      = false
  self.check_y_distance    = 2
  self.is_first_can_switch = true
  self.need_brain_update   = false
end


function se_stalker:get_ini()
  if not self.ini_initialized then
    self.ini             = self:spawn_ini()
    self.ini_initialized = true
    if
      self.ini:section_exist( "logic" )
      and
      get_bool( "logic", "dsh_replace_ini", false, self.ini )
    then
      local cfg = get_string( "logic", "cfg", nil, self.ini )
      if cfg then self.ini = ini_file( cfg ) end
    end
    self.spawner = self:dsh_get_spawner_cond()
    if self.spawner then
      self.cached_spawner = dsh.cached_condlist( self.spawner, 1000 )
    end
  end
end


function se_stalker:dsh_get_spawner_cond()
  local cond
  for _, k in ipairs({ self:name(), self:section_name() }) do
    local dsh_sect = "dsh.se_stalker." .. k .. ".spawner"
    if sys_ini:section_exist( dsh_sect ) then
      cond = get_string( dsh_sect, "cond" )
      break
    end
  end
  if not cond and self.ini:section_exist( "spawner" ) then
    cond = get_string( "spawner", "cond", nil, self.ini )
  end
  if cond then
    return xr_logic.parse_condlist( db.actor_proxy, "spawner", "cond", cond )
  end
end


function se_stalker:can_be_spawned()
  if self.se_respawn then
    if self.se_respawn:is_waiting_register_npc( self.id ) then
      return false
    end
  end
  if self.cached_spawner then
    return self.cached_spawner
      :pick_section_from_condlist( db.actor_proxy, self ) ~= nil
  end
  return true
end


function se_stalker:get_job_online()
  if self.job_online_condlist == nil then
    return self.job_online
  else
    return self.job_online
      :pick_section_from_condlist( db.actor_proxy, self ) ~= nil
  end
end


function se_stalker:can_switch_offline ()
  if self.force_online  then return false end
  if self.force_offline then return true  end

  if self:dsh_avoid_this_level() then
    self.force_offline = true
    return true
  end

  if amk.convert_npc[ self.id ] == true then
    return true
  end

  local job_online = self:get_job_online()
  if job_online ~= false then
    local test = dsh_switch_distances.se_can_switch_offline( self )
    if test ~= nil then
      if self.online == true and self.cached_spawner and test == false then
        return self.cached_spawner
          :pick_section_from_condlist( db.actor, self ) == nil
      end
      return test
    end
  end
  return true
end


function se_stalker:can_switch_online()
  if self.force_online  then return true  end
  if self.force_offline then return false end

  if self.is_first_can_switch then
    self:first_can_switch()
    self.is_first_can_switch = false
  end

  if self:dsh_avoid_this_level() then
    self.force_offline = true
    return false
  end

  if amk.convert_npc[ self.id ] == true then
    return false
  end
  if self.dont_spawn_online == true then
    return false
  end

  local job_online = self:get_job_online()
  if job_online == false then return job_online end

  local cse_can_switch = cse_alife_human_stalker.can_switch_online( self )
  local dsh_can_switch = dsh_switch_distances.se_can_switch_offline( self )
  if dsh_can_switch == false then
    cse_can_switch = true
  elseif cse_can_switch then
    local test = dsh_switch_distances.se_can_switch_online( self )
    if test ~= nil then cse_can_switch = test end
  end

  if db.actor_proxy.online and db.actor:alive() == false then
    return self.online
  end

  if self:can_be_spawned() and cse_can_switch then
    if self.check_distance then
      local dist   = self.position:distance_to( alife():actor().position )
      local y_dist = math.abs( self.position.y - alife():actor().position.y )
      if dist > self.check_distance or y_dist > self.check_y_distance then
        self:set_check_distance( false )
      else
        if not self.check_distance_logged then
          log2(
            "[%s]: %s: switch to online delayed due dist: dist = %s, y_dist = %s, check_distance = %s, check_y_distance = %s",
            script_name(), self:name(), dist, y_dist, self.check_distance, self.check_y_distance
          )
          self.check_distance_logged = true
        end
        return false
      end
    end
    return true
  end
  return false
end


function se_stalker:first_can_switch()
  if not self:alive() then return end
  if amk_offline_alife.is_actors_friend( self ) then return end

  local changed, lc_props = dsh_lc_fixes.has_level_changed()
  local any_smart = changed and lc_props and lc_props.any_smart

  if dsh_lc_fixes.has_level_changed() or self:has_level_changed() then
    local strn, begin_job = dsh_enemies.get_smart_terrain( nil, self )
    if any_smart or ( strn and not begin_job ) then
      if changed and lc_props and lc_props.check_distance then
        self:set_check_distance(
          lc_props.check_distance, lc_props.check_y_distance
        )
      else
        self:set_check_distance()
      end
    else
      self:set_check_distance( 5 )
    end
  end
end


-- Если дружественный сталкер был выгнан из лагеря гулять и его еще не принял к
-- себе никакой смарт, пусть сидит в оффлайне, что бы не шатался бесцельно по
-- локации и не обижал зверушек. А врагам можно, может повоюем лишний раз. На
-- Радаре и в подземке Агропрома никому не нужно без дела слоняться.
function se_stalker:is_homeless_friend()
  local lname = self.level_name
  return
    self:smart_terrain_id() == 65535 and self.was_in_smart_terrain
    and (
      amk_offline_alife.is_actors_friend( self )
      or lname == "l03u_agr_underground" or lname == "l10_radar"
    )
end


function se_stalker:dsh_avoid_this_level()
  if not self:alive() then return false end

  if self:is_homeless_friend() then
    local obj = level.object_by_id( self.id )
    if
      not (
        obj and (
          obj:position():distance_to( db.actor:position() ) < 100
          or ( db.actor:alive() and db.actor:see( obj ) )
        )
      )
    then
      log2(
        "[%s]: %s can't switch online w/o smart_terrain_id",
        script_name(), self:name()
      )
      return true
    end
  end

  if self.online then return false end

  local lname = self.level_name
  if
    -- транзитные в ТД будут только после окончания сцены с Пулей и Максом
    -- или при втором посещении, если кто-то решит забить на долговцев.
    (
      lname == "l04_darkvalley" and alife() and not (
        has_alife_info( "val_actor_has_borov_key" )
        or has_alife_info( "seensak_l04_darkvalley" )
      )
    )
    -- прячем всех во время сходки авторитетов
    or (
      lname == "l03_agroprom"
      and has_alife_info( "father_pant_say_start" )
      and not has_alife_info( "shodka_agro_end" )
    )
    -- прячем всех во время гибели Пантеры
    or (
      lname == "l01_escape"
      and has_alife_info( "esc_pantera_stop_sms" )
      and not has_alife_info( "father_est_2dialog" )
    )
    -- свободовцам через Бар ходить не надо, а долговцам через АС.
    or ( lname == "l05_bar" and self:community() == "freedom" )
    or (
      lname == "l07_military" and not (
        self:community() == "monolith" or self:community() == "zombied"
      )
    )
    -- через МГ можно ходить только после "открытия" МГ
    or (
      lname == "dead_city"
      and not has_alife_info( "agro_tainik_norman_done" )
    )
    -- врагам через Свалку можно ходить только после открытия ворот в Бар
    or (
      lname == "l02_garbage" and not (
        amk_offline_alife.is_actors_friend( self )
        or has_alife_info( "gar_free_pass" )
        or has_alife_info( "sar2_death_18" )
      )
    )
  then
    local strn_id = self:smart_terrain_id()
    if strn_id ~= 65535 then
      local strn_sobj = alife():object( strn_id )
      if strn_sobj then
        return strn_sobj.level_name ~= lname
      end
    end
  end
  return false
end


function se_stalker:STATE_Write (packet)
  cse_alife_human_stalker.STATE_Write (self, packet)

  if self.job_online == true then
    packet:w_u8(0)
  elseif self.job_online == false then
    packet:w_u8(1)
  elseif self.job_online == nil then
    packet:w_u8(2)
  else
    packet:w_u8(3)
    packet:w_stringZ(self.job_online_condlist)
  end

  packet:w_bool(self.was_in_smart_terrain)
  -- Запишем состояние раненности.
  local ddw=0
  if self.death_droped then ddw=ddw+1 end
  if self.wounded then ddw=ddw+2 end
  packet:w_u8(ddw)

  if self.id ~= 65535 then
    packet:w_u32(self.offline_dead)
  end
end
--------------------
function se_stalker:STATE_Read (packet, size)
  cse_alife_human_stalker.STATE_Read (self, packet, size)

  if self.script_version >= 3 then
    local t = packet:r_u8()
    t=bit_and(t,3) -- Задел на будущее
    if t == 0 then
      self.job_online = true
    elseif t == 1 then
      self.job_online = false
    elseif t == 2 then
      self.job_online = nil
    else
      self.job_online_condlist = packet:r_stringZ()
      self.job_online = dsh.cached_condlist(
        xr_logic.parse_condlist(
          nil, "se_stalker:STATE_Read", "job_online", self.job_online_condlist
        ),
        1000
      )
    end
  end

  if self.script_version >= 5 then
    self.was_in_smart_terrain = packet:r_bool()
  end
  if self.script_version >= 6 then
  -- Прочитаем состояние раненности.
    local ddw=packet:r_u8()
    self.death_droped=bit_and(ddw,1)==1
    self.wounded=bit_and(ddw,2)==2
    if self.id ~= 65535 and not packet:r_eof() then
      self.offline_dead = packet:r_u32()
    end
  end
end


function se_stalker:on_before_register()
  local strn_id = self:smart_terrain_id()
  if strn_id ~= 65535 then
    ASSERT(
      alife():object( strn_id ),
      "[%s]: %s: wrong smart_terrain_id(): %s",
      script_name(), self:name(), strn_id
    )
  end
  if dsh.is_free_logic_mob( self ) then
    self:brain():can_choose_alife_tasks( false )
  end
  event( "se_stalker:on_before_register" ):trigger({ sobj = self })
  self:get_ini()
  smart_terrain.fill_exclusives( self )
end


function se_stalker:on_register()
  -- Чистим рестрикторы
  alife():remove_in_restrictions( self )
  cse_alife_human_stalker.on_register( self )
  stalkers[ self.id ] = self

  local community = self:community()
  if
    community ~= "zombied"
    and community ~= "monolith"
    and community ~= "arena_enemy"
  then
    actor_stats.add_to_ranking( self.id )
  end

  -- Регистрация в таскменеджере
  -- task_manager.get_random_task():register_target( self )
  self.se_respawn = se_respawn.get_respawner_by_npc_id( self.id )
  alife():set_interactive( self, true )
  self.on_register_level_name = self.level_name
end


function se_stalker:on_unregister()
  cse_alife_human_stalker.on_unregister( self )
  smart_terrain.unregister_npc( self )

  --' Отрегистрация в таскменеджере
  -- task_manager.get_random_task():unregister_target(self)
  actor_stats.remove_from_ranking( self.id )

  stalkers[ self.id ] = nil
end


function se_stalker:on_spawn()
  cse_alife_human_stalker.on_spawn(self)

end
--------------------
function se_stalker:on_death(killer)
  cse_alife_human_stalker.on_death(self, killer)

--        --' Убрать мапспот с собой
--	if sim_statistic.show_stalker_spot == true then
--		local community, rank = sim_statistic.getNpcType(self)
--		level.map_remove_object_spot(self.id, "alife_presentation_"..community)
--	end

	-- почистим отношения
	local sm = ogse_signals.get_mgr()
	sm:call("on_release_npc", self.id)
end


-- Это включать не нужно, будут проблемы. Ни движок, ни скрипты на это
-- не расчитаны. Проблема в том, что оно работает и клиентские данные
-- сохраняются. При том, все данные, не только то, что скрипты
-- запишут, но и то, что движок сохраняет. В этом-то и
-- проблема. Например, движок сохраняется информацию о best_danger и
-- вот что получается. На Янтаре у долговца был best_danger, ну пусть
-- другой долговец. Теперь мы уходим с локации и best_danger остается
-- в клиентских данных. Через некоторое время этот долговец тоже
-- уходит с Янтаре и мы с ним пересекаемся в Баре. И что мы видим?
-- Долговец в истерике, т.к. у него есть best_danger, который был
-- загружен из клиентских данных, т.к. они не были очищены из-за
-- keep_saved_data_anyway(). Тоже самое с хитовой памятью. На другой
-- локации у непися всплывает хит, m_object которого нет, т.к. он
-- остался на той локации, где хит был нанесен.
--
-- Со скриптами тоже проблема всплывает. Например, в
-- xr_logic. Представим, что непись был в смарте, получил там работу и
-- у него была активная логика. Мы ушли с локации и активная логика
-- была сохранена в клиентских данных. Потом непися выгнали из смарта
-- и его приняли в другой. Все это было в оффлайне и клиентские данные
-- все еще содержат активную логику первоначального смарта. Теперь мы
-- пересекаемся с ним на какой-нибудь локации и тут xr_logic
-- восстанавливает его активную логику и оказывается, что никакой
-- вертекс пути это логики, на этой локации не существует. Движок
-- обижается и падает.
--
-- Переделывать все это я не вижу смысла. Сохранение активной логики
-- скриптовыми методами требует меньших усилий, чем приведение всего
-- этого в порядок.
--
-- function se_stalker:keep_saved_data_anyway()
--   return true
-- end


function se_stalker:has_level_changed()
  return self.level_name ~= self.on_register_level_name
end


function se_stalker:set_check_distance( dist, y_dist )
  if dist == nil then dist = 20 end
  self.check_distance = dist
  if y_dist then self.check_y_distance = y_dist end
end


-- Торговец
class "se_trader" ( cse_alife_trader )
function se_trader:__init( section ) super( section )
end


function se_trader:keep_saved_data_anyway()
  return true
end
