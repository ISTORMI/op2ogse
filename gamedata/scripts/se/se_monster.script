-- -*- mode: lua; coding: windows-1251-dos -*-
--[[
Изменения script_version:
	4 - сохранение поля job_online
	5 - сохранение поля was_in_smart_terrain
	
	modyfied by xStream
]]

need_be_online={}
monsters = {}


class "se_monster" (cse_alife_monster_base)
--------------------
function se_monster:__init (section) super (section)
	self.ini = nil
	self.ini_initialized = false

	self.smart_terrain_conditions     = nil
	self.smart_terrain_conditions_cnt = 0
	self.smart_terrain_conditions_initialized = false

	self.check_distance   = false
	self.check_y_distance = 2
	self.min_distance = 	nil
	self.day_night_switch = false

	-- этот флаг берётся из работы смарта
	-- true     = всегда в онлайне
	-- false    = всегда в офлайне
	-- condlist = условие, которое отпределяет true или false
	-- nil      = смарту всё равно
	self.job_online          = nil
	self.job_online_condlist = nil

	-- посещал ли сталкер хоть один smart_terrain
	self.was_in_smart_terrain = false

	self.day_begin=-1
	self.day_end=-1
	
	self.state = nil

  self.is_first_can_switch = true	
  self.need_brain_update   = false
end
--------------------


function se_monster:get_ini()
  if not self.ini_initialized then
    self.ini             = self:spawn_ini()
    self.ini_initialized = true

    if
      self.ini:section_exist( "logic" )
      and get_bool( "logic", "dsh_replace_ini", false, self.ini )
    then
      local cfg = get_string( "logic", "cfg", nil, self.ini )
      if cfg then self.ini = dsh.cached_ini_file( cfg ) end
    end

    self.spawner = self:dsh_get_spawner_cond()
    if self.spawner then
      self.cached_spawner = dsh.cached_condlist( self.spawner, 1000 )
    end
    if self.ini:section_exist( "spawner" ) then
      self.day_night_switch = get_bool(
        "spawner", "day_night_switch", false, self.ini
      )
      self.day_begin = get_float( self:section_name(), "DayTime_Begin", -1 )
      self.day_end   = get_float( self:section_name(), "DayTime_End",   -1 )
    end
  end
end


function se_monster:dsh_get_spawner_cond()
  local cond
  for _, k in ipairs({ self:name(), self:section_name() }) do
    local dsh_sect = "dsh.se_monster." .. k .. ".spawner"
    if sys_ini:section_exist( dsh_sect ) then
      cond = get_string( dsh_sect, "cond" )
    end
  end
  if not cond and self.ini:section_exist( "spawner" ) then
    cond = get_string( "spawner", "cond", nil, self.ini )
  end
  if cond then
    return xr_logic.parse_condlist( db.actor_proxy, "spawner", "cond", cond )
  end
end


function se_monster:can_be_spawned()
  if self.se_respawn then
    if self.se_respawn:is_waiting_register_npc( self.id ) then
      return false
    end
  end
  if self.cached_spawner then
    return self.cached_spawner
      :pick_section_from_condlist( db.actor_proxy, self ) ~= nil
  end
  return true
end


function se_monster:get_job_online()
  if self.job_online_condlist == nil then
    return self.job_online
  else
    return self.job_online
      :pick_section_from_condlist( db.actor_proxy, self ) ~= nil
  end
end


function se_monster:can_switch_offline()
  if self.force_online  then return false end
  if self.force_offline then return true  end

  if self:dsh_avoid_this_level() then
    return true
  end

  local job_online = self:get_job_online()
  if job_online ~= false then
    local test = dsh_switch_distances.se_can_switch_offline( self )
    if test ~= nil then
      if self.online == true and self.cached_spawner and test == false then
        return self.cached_spawner
          :pick_section_from_condlist( db.actor, self ) == nil
      end
      return test
    end
  end
  return true
end


function se_monster:can_switch_online()
  if self.force_online  then return true  end
  if self.force_offline then return false end

  if self.is_first_can_switch then
    self:first_can_switch()
    self.is_first_can_switch = false
  end

  if self:dsh_avoid_this_level() then
    return false
  end

  local job_online = self:get_job_online()
  if job_online == false then return job_online end

  local cse_can_switch = cse_alife_monster_base.can_switch_online( self )
    and is_creature_day( self, self.day_night_switch )
  local dsh_can_switch = dsh_switch_distances.se_can_switch_offline( self )
  if dsh_can_switch == false then
    cse_can_switch = true
  elseif cse_can_switch then
    local test = dsh_switch_distances.se_can_switch_online( self )
    if test ~= nil then cse_can_switch = test end
  end

  if db.actor_proxy.online and db.actor:alive() == false then
    return self.online
  end

  if self:can_be_spawned() and cse_can_switch then
    if self.check_distance then
      local dist   = self.position:distance_to( alife():actor().position )
      local y_dist = math.abs( self.position.y - alife():actor().position.y )
      if dist > self.check_distance or y_dist > self.check_y_distance then
        self:set_check_distance( false )
      else
        if not self.check_distance_logged then
          log2(
            "[%s]: %s: switch to online delayed due dist: dist = %s, y_dist = %s, check_distance = %s, check_y_distance = %s",
            script_name(), self:name(), dist, y_dist, self.check_distance, self.check_y_distance
          )
          self.check_distance_logged = true
        end
        return false
      end
    end
    return true
  end
  return false
end


function se_monster:first_can_switch()
  if not self:alive() then return end

  local changed, lc_props = dsh_lc_fixes.has_level_changed()
  local any_smart = changed and lc_props and lc_props.any_smart

  if changed or self:has_level_changed() then
    local strn, begin_job = dsh_enemies.get_smart_terrain( nil, self )
    if any_smart or ( strn and not begin_job ) then
      if changed and lc_props and lc_props.check_distance then
        self:set_check_distance(
          lc_props.check_distance, lc_props.check_y_distance
        )
      else
        self:set_check_distance()
      end
    else
      self:set_check_distance( 5 )
    end
  end
end


-- через Бар ходить не надо
function se_monster:dsh_avoid_this_level()
  if not ( alife() and self:alive() ) then return false end

  local lname = self.level_name
  if
    -- мутанты в ТД будут только после окончания сцены с Пулей и Максом
    -- или при втором посещении, если кто-то решит забить на долговцев.
    lname == "l04_darkvalley" and not (
      has_alife_info( "val_escort_scene_end" )
      or has_alife_info( "seensak_l04_darkvalley" )
      -- или рядом с Мессером, что бы его кровосос смог появиться
      or has_alife_info( "val_sos_actor_near_wounded" )
    )
    -- прячем всех во время сходки авторитетов
    or (
      lname == "l03_agroprom"
      and has_alife_info( "father_pant_say_start" )
      and not has_alife_info( "shodka_agro_end" )
    )
    -- прячем всех во время гибели Пантеры
    or (
      level.name() == "l01_escape"
      and has_alife_info( "esc_pantera_stop_sms" )
      and not has_alife_info( "father_est_2dialog" )
    )
  then
    return true
  end

  return false
end


function se_monster:STATE_Write(packet)
	cse_alife_monster_base.STATE_Write (self, packet)
	
	local st = 0
	if self.state == true then
		st=4
	end
	
	if self.job_online == true then
		packet:w_u8(0+st)
	elseif self.job_online == false then
		packet:w_u8(1+st)
	elseif self.job_online == nil then
		packet:w_u8(2+st)
	else
		packet:w_u8(3+st)
		packet:w_stringZ(self.job_online_condlist)
	end
	
	--amk.mylog("writen "..self.id.." state "..st)

	packet:w_bool(self.was_in_smart_terrain)
end
--------------------
function se_monster:STATE_Read(packet, size)
	cse_alife_monster_base.STATE_Read (self, packet, size)

	if self.script_version >= 4 then
		local t = packet:r_u8()
		
		local st = math.floor(t/4)*4
		t=t-st
		if st==4 then need_be_online[self.id]=true end
		
		if t == 0 then
			self.job_online = true
		elseif t == 1 then
			self.job_online = false
		elseif t == 2 then
			self.job_online = nil
		else
			self.job_online_condlist = packet:r_stringZ()
			self.job_online = dsh.cached_condlist( self.job_online_condlist, 1000 )
			self.job_online = dsh.cached_condlist(
			  xr_logic.parse_condlist(
			    nil, "se_monster:STATE_Read", "job_online",
			    self.job_online_condlist
			  ),
			  1000
			)
		end
		--amk.mylog("readed "..self.id.." state "..st)
	end

	if self.script_version >= 5 then
		self.was_in_smart_terrain = packet:r_bool()
	end
	
end


function se_monster:on_before_register()
  local strn_id = self:smart_terrain_id()
  if strn_id ~= 65535 then
    ASSERT(
      alife():object( strn_id ),
      "[%s]: %s: wrong smart_terrain_id(): %s",
      script_name(), self:name(), strn_id
    )
  end
  if dsh.is_free_logic_mob( self ) then
    self:brain():can_choose_alife_tasks( false )
  end
  event( "se_monster:on_before_register" ):trigger({ sobj = self })
  self:get_ini()
  smart_terrain.fill_exclusives( self )
end


function se_monster:on_register()
  -- Чистим рестрикторы
  alife():remove_in_restrictions( self )
  cse_alife_monster_base.on_register( self )
  monsters[ self.id ] = self
  self.se_respawn = se_respawn.get_respawner_by_npc_id( self.id )
  alife():set_interactive( self, true )
  self.on_register_level_name = self.level_name
end


function se_monster:on_unregister()
  cse_alife_monster_base.on_unregister( self )
  smart_terrain.unregister_npc( self )
  monsters[ self.id ] = nil
end


function se_monster:on_death(killer)
	cse_alife_monster_base.on_death(self, killer)

	--' Убрать мапспот с собой
	--[[ квесты Доцента на установки меток на монстров убраны - это больше не нужно
	if sim_statistic.show_monster_spot == true then
		local community, rank = sim_statistic.getNpcType(self)
		if community=="controller" then
		level.map_remove_object_spot(self.id, "kontroler_spot")
		elseif community=="bloodsucker" then
		level.map_remove_object_spot(self.id, "bloodsucker_spot")
		elseif community=="pseudo_gigant" then
		level.map_remove_object_spot(self.id, "pseudo_gigant_spot")
		end
	end
	]]
	
	-- почистим отношения
	local sm = ogse_signals.get_mgr()
	sm:call("on_release_npc", self.id)
end


function is_creature_day(obj, day_night_switch)
	--проверка на дневной/ночной режим
	if day_night_switch then
		if obj.day_begin~=-1 and obj.day_end~=-1 then
			local hrs = level.get_time_hours()
			local de = obj.day_end
			if obj.day_begin>obj.day_end then
				hrs = hrs+24
				de=de+24
			end
			if not (hrs >= obj.day_begin and hrs < de) then
				return false
			end
		end
	end
	return true
end


function se_monster:has_level_changed()
  return self.level_name ~= self.on_register_level_name
end


function se_monster:set_check_distance( dist, y_dist )
  if dist == nil then dist = 20 end
  self.check_distance = dist
  if y_dist then self.check_y_distance = y_dist end
end
