-- -*- mode: lua; coding: windows-1251-dos -*-
--
-- Smart Terrain (механизм, организовывающий всех сталкеров и
-- некоторых монстров в сцены)
--
-- Чугай Александр
-- !без симуляции не работает!

local smart_terrain_choose_start    =  6 * 60 * 1000
local smart_terrain_choose_interval = 12 * 60 * 1000
local smart_terrain_choose_freq     = 1000


function attach(sm)
  sm:subscribe({ signal = "on_spawn", fun = this.on_spawn })
end


-- таблица level_groups задаёт что-то вроде карты, где локации
-- сгруппированы в области.
--
-- Неписи пойдут в смарт с другого уровня, только если этот уровень
-- находится в одной группе со смартом.
--
-- Вероятно, надо глянуть на карту и убедиться, что эти группы заданы
-- осмысленно.  как минимум, группы должны обеспечивать связность
-- графа в пределах локаций одной группы, и также надо согласовывать
-- место спавна неписей и группы, иначе заспавненные неписи не смогут
-- попасть в свой смарт.
--
-- если локация не прописана в этой таблице, то она будет
-- автоматически изолирована.

local level_groups = {
  [ "atp_for_test22" ] = "group1",
  [ "aver"           ] = "group1",
  [ "dead_city"      ] = "group1",
  [ "generators"     ] = "group1",
  [ "hospital"       ] = "group1",
  [ "limansk"        ] = "group1",
  [ "lost_village"   ] = "group1",
  [ "puzir"          ] = "group1",
  [ "red_forest"     ] = "group1",
  [ "warlab"         ] = "group1",

  [ "l01_escape"     ] = "group1",
  [ "l02_garbage"    ] = "group1",
  [ "l03_agroprom"   ] = "group1",
  [ "l03u_agr_underground" ] = "group1",
  [ "l04_darkvalley" ] = "group1",
  -- [ "l04u_labx18"    ] = "group1",
  [ "l05_bar"        ] = "group1",
  [ "l06_rostok"     ] = "group1",
  [ "l07_military"   ] = "group1",
  [ "l08_yantar"     ] = "group1",
  [ "l08u_brainlab"  ] = "group1",
  [ "l10_radar"      ] = "group1",
  [ "l10u_bunker"    ] = "group1",
  [ "l11_pripyat"    ] = "group1",
  [ "l12_stancia"    ] = "group1",
  [ "marsh"          ] = "group1",

  [ "l12_stancia_2"  ] = "group3",
  [ "l12u_control_monolith" ] = "group3",
  [ "l12u_sarcofag"  ] = "group3",

  [ "jupiter"        ] = "group4",
  [ "jupiter_underground" ] = "group4",
  [ "labx8"          ] = "group4",
  [ "pripyat"        ] = "group4",
  [ "zaton"          ] = "group4",
}

local level_groups_patches = {
  {
    -- после дискеты из Лабиринта и открытия Припяти
    [ "cond"  ] = function()
      return db.actor:has_info( "medik_pribor_1_nayti_done" )
        and (
          db.actor:has_info( "pri_stadium_scene_start" )
          or db.actor:has_info( "spawn_prip_dok_sak" )
        )
    end,
    [ "label" ] = "medik_pribor_1_nayti_done",
    [ "patch" ] = {
      [ "av_peshera" ] = "group1",
    },
  },
  -- после окончания сюжета Солянки
  {
    [ "cond"  ] = function()
      return db.actor:has_info( "tel_dcity_kanaliy" )
    end,
    [ "label" ] = "tel_dcity_kanaliy",
    [ "patch" ] = {
      [ "jupiter" ] = "group1",
      [ "jupiter_underground" ] = "group1",
      [ "labx8"   ] = "group1",
      [ "pripyat" ] = "group1",
      [ "zaton"   ] = "group1",
    },
  },
}

local check_period = 10000
local max_idle_end = 86400 * 30


local monster_classes
local disagreed, agreed, agreed_exclusive = 0, 1, 2
local smart_section = "smart_terrains"
local smart_terrains = {}
local smart_terrains_by_name = {}
local exclusives = {}

-- список всех серверных объектов смартов, которые зарегистрированы в симуляторе
-- Формат:
--   smart_terrains = {
--     level_name = { id=obj, id=obj, ... },
--     level_name = { id=obj, id=obj, ... },
--     ...
--   }


function r_str( spawn_ini, section, line, default )
  if spawn_ini:line_exist( section, line ) then
    return spawn_ini:r_string( section, line )
  else
    return default
  end
end


function r_num( spawn_ini, section, line, default )
  if spawn_ini:line_exist( section, line ) then
    return spawn_ini:r_float( section, line )
  else
    return default
  end
end


function r_2nums( spawn_ini, section, line, def1, def2 )
  if spawn_ini:line_exist( section, line ) then
    -- если default-ов больше, чем значений в ini, то забить
    -- недостающие последним значением из ini
    local t = parse_nums( spawn_ini:r_string( section, line ) )
    local n = table.getn( t )
    if n == 0 then
      return def1, def2
    elseif n == 1 then
      return t[ 1 ], def2
    else
      return t[ 1 ], t[ 2 ]
    end
  else
    return def1, def2
  end
end


--------------------------------------------------------------------------------
-- Класс "se_smart_terrain". Обеспечивает поддержку smart terrain в ОФЛАЙНЕ.
-- Унаследован от скриптовой зоны.
--------------------------------------------------------------------------------
class "se_smart_terrain"( cse_alife_smart_zone )
function se_smart_terrain:__init( section ) super( section )
  self.initialized = false
  self.registred   = false
  self.s_storage   = "" -- хранилище данных
end


function se_smart_terrain:detect_probability()
  return 0
end


function se_smart_terrain:print()
  log1( "NPCs:" )
  if self.npc_info then
    for id, v in pairs( self.npc_info ) do
      log2( "    %d %s", id, tostring( v.name ) )
    end
  end
end


-- сохранение
function se_smart_terrain:STATE_Write( packet )
  cse_alife_smart_zone.STATE_Write( self, packet )
  utils.w_CTime( packet, self.duration_end )
  utils.w_CTime( packet, self.idle_end     )
  if self.gulag_working then
    packet:w_bool( true )
    self.gulag:save_common( packet )
    local n = 0
    for id, v in pairs( self.npc_info ) do
      n = n + 1
    end
    packet:w_u8( n )
    for id, v in pairs( self.npc_info ) do
      packet:w_u16( id )
      packet:w_u8( v.o_group )
      packet:w_u8( v.o_squad )
      packet:w_bool( v.exclusive )
      utils.w_CTime( packet, v.stay_end )
      self.gulag:save_obj( packet, id )
    end
    packet:w_bool ( self.population_locked )
  else
    packet:w_bool( false )
  end
  packet:w_stringZ( self.s_storage ) -- допишем его к пакету
end


-- восстановление
function se_smart_terrain:STATE_Read( packet, size )
  cse_alife_smart_zone.STATE_Read( self, packet, size )
  self:read_params()
  -- под LevelEditor не пытаться читать из пакета ничего
  if editor() then return end
  self.duration_end  = utils.r_CTime( packet )
  self.idle_end      = utils.r_CTime( packet )
  if
    self.idle_end > game.get_game_time()
    and self.idle_end:diffSec( game.get_game_time() ) > max_idle_end
  then
    log2(
      "[%s]: %s: idle_end is too big: %s. Reset",
      script_name(), self:name(),
      self.idle_end:diffSec( game.get_game_time() )
    )
    self.idle_end = game.CTime()
  end
  self.gulag_working = packet:r_bool()
  -- если есть работающий гулаг
  if self.gulag_working then
    self.check_time = time_global()
    self.gulag:load_common( packet )
    local n = packet:r_u8()
    for i = 1, n do
      local o_id = packet:r_u16()
      self.npc_info[ o_id ] = {}
      dsh.remember_mobs_smart_terrain( o_id, self, true )
      local o = self.npc_info[ o_id ]
      o.o_group   = packet:r_u8()
      o.o_squad   = packet:r_u8()
      o.exclusive = packet:r_bool()
      o.stay_end  = utils.r_CTime( packet )
      self.gulag:load_obj( packet, o_id )
    end
    self.population_locked = packet:r_bool()
  end
  if not packet:r_eof() then
    -- если есть, загрузим из сохранённой строки
    self.s_storage = packet:r_stringZ()
  end
  self:read_params_late()
end


-- инициализировать работу смарт террейна.
-- после этой функции смарт ПОЛНОСТЬЮ работоспособен.
-- вызывается из всех мест, которые могут вызвать другие объекты:
--   se_smart_terrain:enabled()
--   se_smart_terrain:update()
--   xr_gulag.setup_gulag_and_logic_on_spawn()
--   xr_gulag.get_npc_gulag()
--   xr_gulag.get_gulag_by_name()
--   xr_gulag.get_gulag_by_sid()
function se_smart_terrain:initialize_if_needed()
  if not self.initialized then
    self:get_se_objs()
    self:preserve_exclusives()
    self.gulag:reinit_job_online()
    self.initialized = true
  end
end


function se_smart_terrain:is_initialized()
  return self.initialized
end


-- зарезервировать места для эксклюзивных персонажей
function se_smart_terrain:preserve_exclusives()
  local e = exclusives[ self:name() ]
  if e then
    self.exclusives = e
    self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive - e
    exclusives[ self:name() ] = nil
  else
    self.exclusives = 0
  end
end


-- получить серверные объекты персонажей
function se_smart_terrain:get_se_objs()
  local sim = alife()
  local del = {}
  for id, v in pairs( self.npc_info ) do
    local obj = sim:object( id )
    if obj then
      self:fill_npc_info( obj, v )
    else
      log2(
        "[smart_terrain %s] can't get server object id=%d", self:name(), id
      )
      table.insert( del, id )
    end
  end
  for _, id in ipairs( del ) do
    self.npc_info[ id ] = nil
    self.gulag:removeObject( id )
  end
end


-- заполнить информацию о персонаже
-- у монстров нету метода profile_name()
-- TODO передавать в предикаты не npc_info, а объект
function se_smart_terrain:fill_npc_info( obj, npc_info )
  if not npc_info then
    npc_info = {}
  end
  npc_info.se_obj       = obj
  npc_info.class_id     = obj:clsid()
  npc_info.section_name = obj:section_name()
  npc_info.name         = obj:name()
  npc_info.story_id     = obj.m_story_id
  npc_info.community    = self:get_obj_community( obj )
  npc_info.profile_name = obj.profile_name and obj:profile_name()
  npc_info.rank         = obj:rank()
  npc_info.group        = obj:g_group()
  npc_info.squad        = obj:g_squad()
  npc_info.team         = obj:g_team()
  if npc_info.profile_name then
    npc_info.is_sniper = string.find( npc_info.profile_name, "sniper" ) ~= nil
  end
  npc_info.is_sniper_name = string.find( npc_info.name, "sniper" ) ~= nil
  local t               = obj.smart_terrain_conditions
  if t then
    t = t[ self:name() ]
  end
  npc_info.cond         = t
  return npc_info
end


-- возвращает:
-- а) если сталкер: группировку сталкера и true
-- б) если монстр:  вид монстра и false
function se_smart_terrain:get_obj_community( obj )
  local cls = obj:clsid()
  if cls == clsid.script_stalker then
    return obj:community(), true
  else
    return monster_classes[ cls ], false
  end
end


-- инициализация.
-- чтение custom data.
function se_smart_terrain:read_params()
  local ini  = self:spawn_ini()
  local sect = "smart_terrain"
  if ini:section_exist( "dsh" ) then
    self.dsh_active_profile = get_string( "dsh", "active_profile", nil, ini )
  end
  if not ini:section_exist( sect ) then
    sect = "gulag1"
    if not ini:section_exist( sect ) then
      log2( "[smart_terrain %s] no configuration!", self:name() )
      self.disabled = true
      return
    end
  end
  if not ini:line_exist( sect, "type" ) then
    abort( "[smart_terrain %s] type is not specified", self:name() )
  end
  local gp       = {}
  self.npc_info  = {}           -- group и squad для каждого npc
  self.gparams   = gp           -- настройки гулага
  gp.preset_name = get_string( sect, "preset", nil, ini )
  gp.squad       = get_float( sect, "squad", nil, ini )
  gp.idle_min, gp.idle_max = r_2nums( ini, sect, "idle", 0, 0 )
  gp.duration_min, gp.duration_max = r_2nums(
    ini, sect, "duration", 10000, 10001
  )
  gp.respawn = get_string( sect, "respawn", nil, ini )
  self.rank_inc_min = get_u32( "smart_terrain_rank_change", "min" )
  self.rank_inc_max = get_u32( "smart_terrain_rank_change", "max" )

  self:init_idle_times()
  self:dsh_override_params()

  self.population_locked = false
  self.gulag = xr_gulag.gulag( self, self.npc_info, self.gparams )
  self.gulag_working = false
end


function se_smart_terrain:parse_communities()
  if self.communities then
    local comms = parse_names( self.communities )
    self.accepted_communities = {}
    for i, v in ipairs( comms ) do
      self.accepted_communities[ v ] = true
    end
  end
end


function se_smart_terrain:read_params_late()
  local ini = self:spawn_ini()
  if self.s_storage and self.s_storage ~= "" then
    local s_storage = create_ini_file( self.s_storage )
    if s_storage:section_exist( "dsh" ) then
      ini.readonly = false
      for _, k in ipairs({ "active_profile", "xyzlg" }) do
        local v = get_string( "dsh", k, nil, s_storage )
        if v then
          ini:w_string( "dsh", k, v )
        else
          ini:remove_line( "dsh", k )
        end
      end
      self:save_spawn_ini()
      self.s_storage = ""
    end
  end
  if ini:section_exist( "dsh" ) then
    local xyzlg = get_string( "dsh", "xyzlg", nil, ini )
    if xyzlg then
      self.xyzlg = parse_nums( xyzlg )
      local x, y, z, lvid, gvid = unpack( self.xyzlg )
      if object_level_name( self ) ~= level_system_name_by_gvid( gvid ) then
        log2(
          "[%s]: %s: found wrong xyzlg: %s, %s, %s, %s, %s (%s)",
          script_name(), self:name(), x, y, z, lvid, gvid,
          level_system_name_by_gvid( gvid )
        )
        self.xyzlg = nil
      end
    end
    local profile = get_string( "dsh", "active_profile", nil, ini )
    if profile then
      self:set_active_profile( profile )
    end
  end
end


function se_smart_terrain:set_active_profile( profile, persist )
  if profile ~= self.dsh_active_profile then
    self.dsh_active_profile = profile
    self:dsh_override_params()
  end
  if persist then
    local ini = self:spawn_ini()
    ini.readonly = false
    if profile then
      ini:w_string( "dsh", "active_profile", profile )
    else
      ini:remove_line( "dsh", "active_profile" )
    end
    self:save_spawn_ini()
  end
end


function se_smart_terrain:init_idle_times()
  function parse_idle_time( sect, name )
    local val = get_string( sect, name )
    if val then
      val = parse_nums( val )
      if table.getn( val ) < 2 then
        table.insert( val, val[ 1 ] )
      end
    end
    return val
  end
  for _, suf in ipairs({ "." .. self:name(), "" }) do
    local sect = "dsh.gulag.idle" .. suf
    if sys_ini:section_exist( sect ) then
      self.idle_time_stalker = parse_idle_time( sect, "stalker" )
      self.idle_time_monster = parse_idle_time( sect, "monster" )
      break
    end
  end
end


function se_smart_terrain:dsh_override_params()
  local ini  = self:spawn_ini()
  local sect = "smart_terrain"
  if not ini:section_exist( sect ) then
    sect = "gulag1"
  end
  ASSERT(
    ini:section_exist( sect ),
    "[%s]: %s: default section not found", script_name(), self:name()
  )

  local gp = self.gparams
  gp.capacity = get_float(  sect, "capacity", 100, ini )
  gp.cond     = get_string( sect, "cond",     nil, ini )
  gp.groups   = get_string( sect, "groups",   nil, ini )
  gp.type     = get_string( sect, "type",     nil, ini )
  gp.stay_min, gp.stay_max = smart_terrain_params.get_stay_time_interval(
    get_string( sect, "stay", "default", ini )
  )
  self.accepted_communities = nil
  self.communities = get_string( sect, "communities", nil, ini )
  self.on_cleanup  = nil
  self.smart_terrain_task = nil

  local dsh_override_opts = {
    [ "capacity" ] = {
      [ "getter" ] = function( ... ) return get_float(  ... ) end,
      [ "setter" ] = function( v ) gp.capacity = v end,
    },
    [ "communities" ] = {
      [ "getter" ] = function( ... ) return get_string( ... ) end,
      [ "setter" ] = function( v ) self.communities = v end,
    },
    [ "cond" ] = {
      [ "getter" ] = function( ... ) return get_string( ... ) end,
      [ "setter" ] = function( v ) gp.cond = v end,
    },
    [ "groups" ] = {
      [ "getter" ] = function( ... ) return get_string( ... ) end,
      [ "setter" ] = function( v ) gp.groups = v end,
    },
    [ "on_cleanup" ] = {
      [ "getter" ] = function( ... ) return get_string( ... ) end,
      [ "setter" ] = function( v ) self.on_cleanup = v end,
    },
    [ "smart_terrain_task" ] = {
      [ "getter" ] = function( ... ) return get_string( ... ) end,
      [ "setter" ] = function( v ) self.smart_terrain_task = v end,
    },
    [ "stay" ] = {
      [ "getter" ] = function( ... ) return get_numbers( ... ) end,
      [ "setter" ] = function( v )
        gp.stay_min = v[ 1 ]
        if table.getn( v ) > 1 then
          gp.stay_max = v[ 2 ]
        else
          gp.stay_max = v[ 1 ]
        end
      end,
    },
    [ "type" ] = {
      [ "getter" ] = function( ... ) return get_string( ... ) end,
      [ "setter" ] = function( v ) gp.type = v end,
    },
  }

  local dsh_sect = "dsh.gulag.override." .. self:name()
  local profile  = self.dsh_active_profile
  if profile then
    sect = dsh_sect .. "." .. profile
  else
    sect = dsh_sect
  end
  if sys_ini:section_exist( sect ) then
    for k, v in pairs( dsh_override_opts ) do
      if sys_ini:line_exist( sect, k ) then
        local value = v.getter( sect, k )
        v.setter( value )
      end
    end
  end

  self:parse_communities()
  if gp.cond then
    gp.cond = dsh.cached_condlist(
      xr_logic.parse_condlist( nil, sect, "cond", gp.cond ), 1000
    )
  end
  if gp.groups then
    gp.groups = parse_nums( gp.groups )
  end
  if self.gulag then
    self.gulag:set_capacity( gp.capacity )
  end
end


-- подходит ли персонаж по предустановкам.
-- если такой предустановки нету, то он всегда подходит.
function se_smart_terrain:check_preset( npc_community, npc_rank, preset_name )
  local preset = smart_terrain_params.get_preset( preset_name )
  if preset == false then
    return true
  else
    local t = preset[ npc_community ]
    if t and ( npc_rank >= t[ 1 ] and npc_rank <= t[ 2 ] ) then
      return true
    else
      return false
    end
  end
end


-- подходит ли объект гулагу?
--
-- 1) если объект не согласен сюда идти, то smart terrain его не возьмёт
--
-- 2) если объект согласен идти куда угодно, то проверить, есть ли ещё
--    места, подходит ли он гулагу, подходит ли он хоть на одну работу
--
-- 3) если объект согласен идти только в этот смарт, то принимаем даже
--    если нету места (он вытеснит кого-то), проверить, подходит ли он
--    гулагу, подходит ли он хоть на одну работу


function is_same_level_group( strn_lname, sobj )
  local npc_lname = ""
  if game_graph():valid_vertex_id( sobj.m_game_vertex_id ) then
    npc_lname = object_level_name( sobj )
  end

  -- Если вылеченный сталкер сидит в X-18, то ему можно оттуда выбраться, если
  -- какой-то смарт хочет принять его к себе. Даже не смотря на то, что из X-18
  -- никого принимать нельзя, т.к. этой локации нет в level_groups.
  if
    IsStalker( sobj ) and sobj:is_homeless_friend()
    and level_groups[ strn_lname ]
    and not level_groups[ npc_lname ]
  then
    return true
  end

  local g1 = level_groups[ strn_lname ] or strn_lname
  local g2 = level_groups[ npc_lname  ] or npc_lname

  return g1 == g2
end


-- Подходит ли объект гулагу.
-- Второй аргумент - результат работы функии obj_accepts_smart_terrain - тип
-- согласия объекта на вступление в этот смарт.
-- Вызывается как часть enabled
function se_smart_terrain:smart_terrain_accepts_obj( obj, obj_agreement )
  if obj_agreement == disagreed then -- объект в этот смарт идти не хочет
    return false
  end

  -- в любом случае, если хочет идти только в этот, или если готов без
  -- условий и при этом гулаг не заполнен полностью
  if
    obj_agreement == agreed_exclusive
    or self.gulag:get_non_exclusive_population() < self.gulag.capacity_non_exclusive
  then
    local community, is_stalker = self:get_obj_community( obj )
    -- фантомов не принимаем никуда
    if not community then return false end
    -- мертвых не принимаем тоже
    if not obj:alive() then return false end
    -- Проверка что смарттеррейн и НПС находятся в одном кластере уровней (чтобы
    -- не ходили через БАР)
    if not is_same_level_group( self:get_level_name(), obj ) then
      return false -- с этого уровня в этот смарт идти нельзя
    end
    -- если в кастомдате смарта есть перечень допустимых группировок и
    -- непись не попадает в эту группировку
    if
      self.accepted_communities and not self.accepted_communities[ community ]
    then
      if obj_agreement == agreed_exclusive then
        log2(
          "[%s]: [%s] %s (%s) ignores accepted_communities because agreed_exclusive",
          script_name(), self:name(), obj:name(), obj.level_name
        )
      else
        return false            -- то не подходит
      end
    end
    -- выполнить проверку, заданную скриптом для конкретного уровня
    -- (обычно соответствие типа гулага и параметров непися)
    if not self.gulag:checkNpc( community, is_stalker, obj:rank(), obj ) then
      return false
    end
    -- если есть работа
    return self.gulag:is_there_any_suitable_job(
      self:fill_npc_info( obj ), obj_agreement == agreed_exclusive
    )
  else
    -- если не эксклюзив для этого смарта и места нет, то не подходит
    return false
  end
end


-- подходит ли гулаг объекту?
--
-- у объекта в custom data прописаны условия для некоторых smart_terrains:
--         <smart_terrain_name1> = <condlist1>
--         <smart_terrain_name2> = <condlist2>
--         ...
-- Если для какого-то smart_terrain условие выполнилось, он называется
-- эксклюзивным.
-- Если у объекта появился хоть один эксклюзивный smart terrain, то он будет
-- согласен идти только в него.
-- Если не появилось ни одного эксклюзивного, то он согласен идти в любой.
-- Функция возвращает одно из трёх значений:
-- disagreed        - в этот не идёт
-- agreed_exclusive - идёт только в этот
-- agreed           - согласен идти в этот на неэкслюзивной основе
--
-- TODO а если в начале эксклюзивный, а потом в любой?
-- вариант: any=condlist
function se_smart_terrain:obj_accepts_smart_terrain( obj )
  -- если вообще есть какие-то специальные условия насчёт смартов
  local conds = obj.smart_terrain_conditions
  if conds then
    local done = true
    -- перебираем все варианты условий из секции непися
    if
      xr_logic.pick_section_from_condlist(
        db.actor_proxy, obj, conds[ "none" ]
      ) ~= nil
    then
      return disagreed -- явно прописано, что не идёт ни в какой смарт
    elseif
      xr_logic.pick_section_from_condlist(
        db.actor_proxy, obj, conds[ self:name() ]
      ) ~= nil
    then
      return agreed_exclusive   -- идёт только в этот смарт
    elseif
      xr_logic.pick_section_from_condlist(
        db.actor_proxy, obj, conds[ "any" ]
      ) ~= nil
    then
      done = false              -- разрешили идти в любой смарт
    end
    if done then
      return disagreed          -- в этот не идёт
    end
  end

  -- здесь имеем: эксклюзивов нет, явного запрета тоже нет
  --
  -- Если объекту запрещено переходить в online и эксклюзивные '
  -- смарты недоступны, то не пускаем его никуда. Это исключает '
  -- переброску отключенных до (или после) определённого события '
  -- людей и мутантов в другой неэксклюзивный смарт.
  if not obj:can_be_spawned() then
    if
      not (
        -- ждет, когда его примет какой-нибудь смарт
        obj.se_respawn
        and obj.se_respawn:is_waiting_register_npc( obj.id )
      )
    then
      return disagreed
    end
  end

  return agreed
end


-- может ли объект быть добавлен в smart terrain?
-- вызывается симулятором при поиске задания для объекта/группы.
-- если объект - группа, то вернёт true только если все объекты в
-- группе вернут true
local last_obj_accepts
local reject_timers = {}

function se_smart_terrain:enabled( obj )
  -- enabled(), suitable() и register_npc() вызываются из движка одним
  -- непрерывным циклом и можно быть уверенным, что к моменту
  -- следующего апдейта он будет завершен и моб либо будет принят
  -- каким-нибудь смартом, либо не будет принят никаким.
  if not reject_timers[ obj.id ] then -- начался цикл поиска смарта для моба
    reject_timers[ obj.id ] = dsh.exec_on_update(
      -- если на следующем апдейте этот таймер сработает, значит смарт
      -- не был найден и нужно известить об этом респаунер
      function( id )
        reject_timers[ id ] = nil
        local sobj = alife():object( id )
        if
          sobj and sobj.se_respawn
          and sobj.se_respawn:is_waiting_register_npc( id )
        then
          sobj.se_respawn:on_smart_terrain_reject_npc( sobj )
        end
      end, obj.id
    )
  end

  if self.disabled then
    return false
  end

  -- если всё это делаем в первый раз проинитим ...вообще-то это
  -- должно с гарантией происходить при создании смарта движком,
  self:register_if_needed()
  self:initialize_if_needed()   -- но на всякий случай...

  -- если гулаг активен (по cond_list из кастомдаты смарта) и не
  -- заблокировано добавление персонажей
  if self:is_gulag_available() then
    -- если смарт подходит неписю
    last_obj_accepts = self:obj_accepts_smart_terrain( obj )
    if last_obj_accepts == agreed_exclusive or not self:is_locked() then
      -- и непись подходит смарту
      return self:smart_terrain_accepts_obj( obj, last_obj_accepts )
    end
  end
  return false
end


function se_smart_terrain:is_locked()
  if
    self.population_locked
    or ( self.idle_end and self.idle_end > game.get_game_time() )
    or ogse_st_mgr.timer_exists(
      "smart_terrain." .. self:name() .. ".population_locked"
    )
  then
    return true
  end
  return false
end


-- возвращает меру подходящести персонажа смарттерейну.
--
-- вызывается для всех смарттерейнов, которые вернули true из enabled
--
-- на основе это функции принимается решение для непися (не смарта),
-- т.е. здесь непись выбирает себе смарт. Для какого смарта число
-- больше, туда и пойдёт
function se_smart_terrain:suitable( obj )
  -- Повысить подходящесть эксклюзивного смарттеррейна
  if last_obj_accepts == agreed_exclusive then
    -- Так чтобы все эксклюзивные были заведомо лучше сразу возвращаем, зачем
    -- ещё что-то проверять, если это заведомо больше всех
    return 100000
  end

  if obj.level_name ~= self.level_name then
    -- смарт на другой локации будет привлекательнее смарта на локации непися.
    -- Полагаю, это приведет к большей движухе.
    if self.level_name == level.name() then
      -- пусть с других локаций первым делом идут к актору
      return math.random( 201, 300 )
    else
      return math.random( 101, 200 )
    end
  end

  return math.random( 100 )
end


-- добавить npc в smart terrain.  если места нету или нету свободных
-- подходящих работ, то вытолкнуть из этого smart terrain с подходящей
-- работы объект, который попал в него не эксклюзивно.
function se_smart_terrain:register_npc( obj )
  ASSERT(
    obj:alive(),
    "[%s]: %s trying to register dead npc %s",
    script_name(), self:name(), obj:name()
  )
  -- log2(
  --   "[smart_terrain %s] register called obj=%s gulag_type=%s",
  --   self:name(), obj:name(), self.gparams.type
  -- )
  if reject_timers[ obj.id ] then
    -- моб был принять смартом и нужно остановить таймер, который
    -- сработает на апдейте и уведомит респаунер, что моба никто не
    -- принял
    reject_timers[ obj.id ]:stop()
    reject_timers[ obj.id ] = nil
  end

  if obj.se_respawn then
    obj.se_respawn:on_smart_terrain_register_npc( obj, self )
  end

  local npc_info = {
    -- старые squad и group
    o_group   = obj:g_group(),
    o_squad   = obj:g_squad(),
    exclusive = self:obj_accepts_smart_terrain( obj ) == agreed_exclusive,
    stay_end  = game.get_game_time()
  }
  self:fill_npc_info( obj, npc_info )

  if
    self.gulag_working
    and not self.gulag:is_there_any_suitable_job( npc_info, false )
  then
    log2(
      "get_population = %d, capacity = %d",
      self.gulag:get_population(), self.gulag.capacity
    )
    log2(
      "is_there_any_suitable_job = %s",
      tostring( self.gulag:is_there_any_suitable_job( npc_info, false ) )
    )
    print_table( self.npc_info )
    self:kick_someone_non_exclusive( npc_info )
  end

  if obj.was_in_smart_terrain then
    self:update_obj_rank( obj )
  end
  obj.was_in_smart_terrain = true
  self.npc_info[ obj.id ] = npc_info

  if not self.gulag_working then
    self:create_gulag()
  end
  self.gulag:addObject( obj.id )
  self.gulag:update()
  dsh_switch_distances.reset_cache( obj )

  if db.actor_proxy.online and self.gulag:dsh_is_full() then
    local sm = ogse_signals.get_mgr()
    sm:call( "on_full_smart_terrain", self )
  end

  if obj.last_alife_task then
    if obj.level_name ~= self.level_name then
      obj.last_alife_task_ttl = time_global() + math.random( 10 ) * 60 * 1000
      -- log2(
      --   "[%s]: [%s] %s (%s) set last_alife_task_ttl[%s]",
      --   script_name(), self:name(), obj:name(), obj.level_name,
      --   obj.last_alife_task_ttl - time_global()
      -- )
    else
      -- log2(
      --   "[%s]: [%s] %s (%s) clear last_alife_task",
      --   script_name(), self:name(), obj:name(), obj.level_name
      -- )
      obj.last_alife_task = nil
    end
  end
  -- log2(
  --   "[smart_terrain %s] added %s to gulag type=%s",
  --   self:name(), obj:name(), self.gparams.type
  -- )

  news_main.on_spawn( obj )
end


-- отпустить npc
-- TODO а если такого объекта уже нету?
function se_smart_terrain:unregister_npc( obj, ignore_on_empty )
  -- Если анрегистрим мертвого эксклюзивного НПС, нужно уменьшить
  -- счетчик эксклюзивности
  if obj.smart_terrain_conditions then
    local any_exclusive = false
    for name, condlist in pairs( obj.smart_terrain_conditions ) do
      local s = xr_logic.pick_section_from_condlist(
        db.actor_proxy, obj, condlist
      )
      if s ~= nil then
        if name == self:name() then
          -- уменьшаем счетчик
          self.exclusives = self.exclusives - 1
          self.gulag.capacity_non_exclusive =
            self.gulag.capacity_non_exclusive + 1
        end
      end
    end
  end

  local n = self.npc_info[ obj.id ]
  if not n then
    log1( debug.traceback() )
    log2( "self.npc_info[obj.id] = nil !!! obj.id=%d", obj.id )
    self:print()
    self.gulag:print()
  end

  local begin_job = ( self.gulag.Object_didnt_begin_job[ obj.id ] == false )
  self.gulag:removeObject( obj.id )
  obj.squad = n.o_squad
  obj.group = n.o_group
  if IsStalker( obj ) and obj:alive() and not alife():is_unloading() then
    local species = get_string( obj:section_name(), "species" )
    local team    = level.get_character_community_team( obj:community() )
    ASSERT(
      team,
      "[%s]: got undefined team for %s: community[%s]",
      script_name(), obj:name(), obj:community()
    )
    if species == "human" and obj.team ~= team then
      -- log2(
      --   "[%s]: %s: change team back to %s for %s: %s -> %s",
      --   script_name(), self:name(), obj:community(), obj:name(), obj.team, team
      -- )
      local cobj = level.object_by_id( obj.id )
      if cobj then
        cobj:change_team( team, obj.squad, obj.group )
      else
        obj.team = team
      end
    end
  end
  self.npc_info[ obj.id ] = nil
  obj:clear_smart_terrain()
  dsh.remember_mobs_smart_terrain( obj.id, self, false )
  obj:brain():can_choose_alife_tasks( true )
  dsh_switch_distances.reset_cache( obj )

  if self:is_empty() and db.actor_proxy.online and not ignore_on_empty then
    local sm = ogse_signals.get_mgr()
    sm:call( "on_empty_smart_terrain", self, obj, begin_job )
  end
  -- log2(
  --   "[smart_terrain %s] removed %s from gulag type=%s, strn_id=%s",
  --   self:name(), obj:name() or "<<<nil>>>", self.gparams.type, obj:smart_terrain_id()
  -- )
end


function se_smart_terrain:is_empty()
  for id, v in pairs( self.npc_info ) do
    return false
  end
  return true
end


-- изменть ранг сталкера при регистрации в смарт
function se_smart_terrain:update_obj_rank( sobj )
  local community, is_stalker = self:get_obj_community( sobj )
  if not is_stalker then return end
  local obj      = level.object_by_id( sobj.id )
  local new_rank = math.random( self.rank_inc_min, self.rank_inc_max )
  local old_rank
  if obj then
    old_rank = obj:character_rank()
    obj:change_character_rank( new_rank )
    -- log2(
    --   "[smart_terrain %s] obj=%s rank %d -> %d",
    --   self:name(), obj:name(), old_rank, obj:character_rank()
    -- )
  else
    old_rank = sobj:rank()
    sobj:set_rank( old_rank + new_rank )
    -- log2(
    --   "[smart_terrain %s] sobj=%s rank %d -> %d",
    --   self:name(), sobj:name(), old_rank, sobj:rank()
    -- )
  end
end


-- выгнать из-под смарттеррейна первого попавшегося неэксклюзивного
-- персонажа, который занимает работу, подходящую новому персонажу.
--
-- TODO а если я выгоню кого-то, а его работа не подойдёт по idle ?
function se_smart_terrain:kick_someone_non_exclusive( new_npc_info )
  for obj_id, npc_info in pairs( self.npc_info ) do
    if
      ( not npc_info.exclusive )
      and self.gulag:obj1_job_suits_obj2( obj_id, new_npc_info )
    then
      log2(
        "[smart_terrain %s] kicking %s because %s",
        self:name(), npc_info.name, new_npc_info.name
      )
      self:unregister_npc( npc_info.se_obj )
      return
    end
  end
  abort(
    "[smart_terrain %s] can't add npc %s, all are exclusive or there are no suitable jobs",
    self:name(), new_npc_info.name
  )
end


-- выдать объекту задание.
function se_smart_terrain:task( sobj )
  ASSERT(
    ( not dsh.is_free_logic_mob( sobj ) ),
    "smart_terrain %s is trying to assign task to %s",
    self:name(), sobj:name()
  )
  local job = self.gulag:getJob( sobj.id )
  if not ( job and job.alife_task ) then
    log2(
      "[smart_terrain %s] task: sobj=%s alife_task=nil, CLEARING",
      self:name(), sobj:name()
    )
    self:unregister_npc( sobj )  --'Затычка против вылета.
    return CALifeSmartTerrainTask( "simulation_default_path" )
  end
  if sobj.last_alife_task then
    if sobj.last_alife_task_ttl < time_global() then
      -- log2(
      --   "[%s]: [%s] %s (%s) last_alife_task expired ttl[%s]",
      --   script_name(), self:name(), sobj:name(), sobj.level_name,
      --   sobj.last_alife_task_ttl - time_global()
      -- )
      sobj.last_alife_task     = nil
      sobj.last_alife_task_ttl = nil
    else
      -- log2(
      --   "[%s]: [%s] %s (%s) use last_alife_task ttl[%s]",
      --   script_name(), self:name(), sobj:name(), sobj.level_name,
      --   sobj.last_alife_task_ttl - time_global()
      -- )
      return sobj.last_alife_task
    end
  end
  return job.alife_task
end


-- может ли данный гулаг создаться в данный момент?
function se_smart_terrain:is_gulag_available()
  if self.gparams.cond then
    return self.gparams.cond
      :pick_section_from_condlist( db.actor_proxy, self ) ~= nil
  else
    return true
  end
end


-- установка/снятие блокировки приёма персонажей
function se_smart_terrain:lock_population( need_lock )
  self.population_locked = need_lock
end


-- в гулаг поступил первый персонаж и он начинает работать
function se_smart_terrain:create_gulag()
  self.duration_end = game.CTime()
  self.duration_end:setHMSms(
    math.random( self.gparams.duration_min, self.gparams.duration_max ), 0, 0, 0
  )
  self.duration_end:add( game.get_game_time() )
  self.check_time = time_global()
  self.gulag:initialize()
  self.gulag_working = true
end


-- всех освободить, убить гулаг, создать новый нерабочий гулаг,
-- зарезервировать в нём места для эксклюзивных
function se_smart_terrain:remove_gulag( disable, ignore_on_empty )
  self.disabled = disable
  if not self.gulag_working then
    return
  end
  -- log2(
  --   "[smart_terrain %s] removed gulag type=%s", self:name(), self.gparams.type
  -- )
  -- освободить всех персонажей
  for id, npc_info in pairs( self.npc_info ) do
    self:unregister_npc( npc_info.se_obj, ignore_on_empty )
    -- если смарт закрылся, попытаемся всех распределить по другим смартам,
    -- как можно быстрее. Что бы не бродили неприкаянные и получили свою
    -- логику.
    smart_brain_update( npc_info.se_obj )
  end
  self.gulag = xr_gulag.gulag( self, self.npc_info, self.gparams )
  self.gulag:load_jobs()
  self.gulag.capacity_non_exclusive =
    self.gulag.capacity_non_exclusive - self.exclusives
  self.gulag_working     = false
  self.population_locked = false
end


-- заполняет таблицу monster_classes
function se_smart_terrain:fill_monster_classes()
  if not monster_classes then
    monster_classes = {
      [clsid.bloodsucker_s ] = "bloodsucker",
      [clsid.boar_s        ] = "boar",
      [clsid.burer_s       ] = "burer",
      [clsid.cat_s         ] = "cat",
      [clsid.chimera_s     ] = "chimera",
      [clsid.controller_s  ] = "controller",
      [clsid.pseudodog_s   ] = "pseudodog",
      [clsid.psy_dog_s     ] = "psy_dog",
      [clsid.dog_s         ] = "dog",
      [clsid.flesh_s       ] = "flesh",
      [clsid.fracture_s    ] = "fracture",
      [clsid.poltergeist_s ] = "poltergeist",
      [clsid.gigant_s      ] = "pseudo_gigant",
      [clsid.snork_s       ] = "snork",
      [clsid.tushkano_s    ] = "tushkano",
      [clsid.zombie_s      ] = "zombie"
    }
  end
end


-- возвращает название уровня, на котором находится smart terrain
function se_smart_terrain:get_level_name()
  return object_level_name( self )
end

-- регистрация объекта в симуляторе.
-- вызывается симулятором.
function se_smart_terrain:on_register()
  cse_alife_smart_zone.on_register( self )
  self:register_if_needed()
  self:initialize_if_needed()
end


function se_smart_terrain:register_if_needed()
  --' Если уже зарегистрены то ничего не делать.
  if self.registred == true then
    return
  end
  self.registred = true
  -- log2( "%s register called", self:name() )
  if self.disabled then
    return
  end
  self:fill_monster_classes()
  local level_name = self:get_level_name()
  if not self.gparams.preset_name then
    self.gparams.preset_name = level_name
  end
  if not smart_terrains[ level_name ] then
    smart_terrains[level_name] = {}
  end
  smart_terrains[ level_name ][ self.id ] = self
  smart_terrains_by_name[ self:name() ]   = self
  if self.gparams.respawn then
    db.strn_by_respawn[ self.gparams.respawn ] = self
  end
  self.gulag:load_jobs()
  if self.gulag_working then
    self.gulag:initialize()
  end
  -- Регистрация в таскменеджере
  task_manager.get_random_task():register_target( self )
end


-- дерегистрация объекта в симуляторе.
-- вызывается симулятором.
function se_smart_terrain:on_unregister()
  cse_alife_smart_zone.on_unregister( self )
  -- log2( "[smart_terrain %s] on_unregister called", self:name() )
  local lvl_smarts = smart_terrains[ self:get_level_name() ]
  if lvl_smarts then
    lvl_smarts[ self.id ] = nil
  end
  smart_terrains_by_name[ self:name() ] = nil
  if self.gparams and self.gparams.respawn then
    db.strn_by_respawn[ self.gparams.respawn ] = nil
  end
  db.actor_proxy:deinit()
end


-- вызвать спавнер, если настроен.
function se_smart_terrain:call_respawn()
  if self.gparams.respawn then
    se_respawn.spawn( self.gparams.respawn )
  end
end


-- возвращает строку с принимаемыми группировками и рангами
function se_smart_terrain:stat_get_accepted_communities()
  local comms = {}
  -- from preset
  local iniFileName = "misc\\" .. self.gparams.type .. ".ltx"
  local preset_name = self.gparams.preset_name
  if iniLineSectionExist( preset_name, iniFileName ) then
    local n = iniLinesCount( preset_name, iniFileName )
    for i = 0, n - 1 do
      local result, field, str = getIniLine(
        preset_name, i, "", "", iniFileName
      )
      if
        ( not self.accepted_communities )
        or self.accepted_communities[field]
      then
        comms[ field ] = str
      end
    end
  end
  -- from custom data
  if self.accepted_communities then
    for comm, v in pairs( self.accepted_communities ) do
      if not comms[ comm ] then
        comms[ comm ] = "all"
      end
    end
  end
  -- prepare return
  local s = ""
  for comm, ranks in pairs( comms ) do
    s = s .. comm .. "(" .. ranks .. "),"
  end
  return s
end


-- вывод статистики смарта
function se_smart_terrain:stat()
  local s     = self:get_level_name() .. " " .. self:name()
  local pop   = self.gulag:get_population()
  local cap   = self.gulag.capacity
  local avail = self:is_gulag_available()
  if avail then
    s = s .. " enabled "
  else
    s = s .. " disabled "
  end
  s = s .. pop .. " " .. cap .. " " .. self:stat_get_accepted_communities()
  log1( s )
  for id, npc_info in pairs( self.npc_info ) do
    log2( "    %s", npc_info.name )
  end
  return avail, pop, cap
end


-- Обновление.
-- В онлайне вызывается через binder.
-- Также может вызваться принудительно из xr_effects
-- Если мужиков в гулаге больше не осталось или условия существования
-- гулага не выполняются, то убрать гулаг.
function se_smart_terrain:update()
  cse_alife_smart_zone.update( self )
  if self.has_waiting_exclusive and self:is_gulag_available() then
    self.has_waiting_exclusive = false
    self:register_waiting_exclusives()
  end
  if not self.gulag_working then
    return
  end
  if self:is_gulag_available() then
    if self.check_time <= time_global() then
      self.check_time = time_global() + check_period
      -- проверять, не собрался ли кто-то к этому времени уже уходить
      local this_smart_lname = object_level_name( self )
      for id, npc_info in pairs( self.npc_info ) do
        local sobj = npc_info.se_obj
        if not sobj:alive() then
          log2(
            "[%s]: %s: %s is dead on update",
            script_name(), self:name(), sobj:name()
          )
          self:unregister_npc( sobj )
        elseif self.need_kick and self.need_kick[ id ] then
          log2(
            "[%s]: %s: kicking %s by request",
            script_name(), self:name(), sobj:name()
          )
          self.need_kick[ id ] = nil
          self:unregister_npc( sobj, true )
          smart_brain_update( sobj )
        elseif
          npc_info.cond
          and xr_logic.pick_section_from_condlist(
            db.actor_proxy, sobj, npc_info.cond
          ) == nil
        then
          -- log2( "[smart_terrain %s] leaving %s", self:name(), sobj:name() )
          self:unregister_npc( sobj )
          -- если выгнали кого-то потому, что у него переключился
          -- смарт, сразу же обновим ему мозги, что бы его подхватил
          -- новый смарт и дал ему логику.
          smart_brain_update( sobj )
        elseif
          dsh.is_free_logic_mob( sobj )
          and object_level_name( sobj ) ~= this_smart_lname
        then
          log2(
            "[%s]: %s: free_logic_mob %s found on level %s instead of %s",
            script_name(), self:name(), sobj:name(),
            object_level_name( sobj ), this_smart_lname
          )
          self:unregister_npc( sobj )
          sobj:brain():can_choose_alife_tasks( true )
        end
      end
      if self.gulag:get_population() == 0 then
        self:remove_gulag( self.id )
      else
        self.gulag:update()
      end
    end
  else
    if self.on_cleanup then
      local f, err = loadstring( "return " .. self.on_cleanup .. "( ... )" )
      ASSERT( f, err )
      f( self )
    end
    self:remove_gulag()
  end
end


function se_smart_terrain:dsh_begin_job( id )
  local t = game.CTime()
  t:setHMSms(
    math.random( self.gparams.stay_min, self.gparams.stay_max ),
    math.random( 0, 59 ), 0, 0
  )
  t:add( game.get_game_time() )
  self.npc_info[ id ].stay_end = t
end


function se_smart_terrain:set_idle_timer( hours, not_exists )
  local tname  = "smart_terrain." .. self:name() .. ".population_locked"
  if ogse_st_mgr.timer_exists( tname ) then
    if not_exists then
      return false
    end
    local t = ogse_st_mgr.get_timer( tname )
    t:stop()
  end
  local t = dsh.start_gtimerDHMS(
    tname, 0, hours, 0, 0, "smart_terrain.on_after_idle_timer", self.id
  )
  self.idle_end = t:get_end_time()
  ASSERT(
    self.idle_end:diffSec( game.get_game_time() ) <= max_idle_end,
    "[%s]: %s: new idle_end is too big: %s, hours = %s",
    script_name(), self:name(),
    self.idle_end:diffSec( game.get_game_time() ),
    tostring( hours )
  )
  return true
end


function on_after_idle_timer( strn_id )
  if strn_id then
    strn_id = tonumber( strn_id )
    local strn = alife():object( strn_id )
    ASSERT( strn, "smart_terrain id = %s not found", strn_id )
    strn.idle_end = game.CTime()
  end
end


function se_smart_terrain:try_set_idle_timer( last_sobj )
  if self.idle_time_monster or self.idle_time_stalker then
    ASSERT(
      ( IsStalker( last_sobj ) or IsMonster( last_sobj ) ),
      "unknown last_sobj: %s", last_sobj:name()
    )
    local t_min, t_max
    if IsStalker( last_sobj ) and last_sobj:community() ~= "zombied" then
      if self.idle_time_stalker then
        t_min, t_max = unpack( self.idle_time_stalker )
      end
    else
      if self.idle_time_monster then
        t_min, t_max = unpack( self.idle_time_monster )
      end
    end
    if t_min and t_max then
      local hours = ( t_min == t_max ) and t_max or math.random( t_min, t_max )
      if hours > 0 then
        -- блокировать смарт на hours часов, если он еще не заблокирован.
        if self:is_empty() then
          self:set_idle_timer( hours, true )
        else
          -- если смарт не опустел, то дадим время ему опустеть. Не будем
          -- некоторое время никого принимать. А то есть вероятность, что
          -- кто-нибудь немедленно в нем зарегистрируется и тогда он уже не
          -- опустеет.
          self.idle_end = game.CTime()
          self.idle_end:setHMSms( hours, 0, 0, 0 )
          self.idle_end:add( game.get_game_time() )
          ASSERT(
            self.idle_end:diffSec( game.get_game_time() ) <= max_idle_end,
            "[%s]: %s: new idle_end is too big: %s, hours = %s",
            script_name(), self:name(),
            self.idle_end:diffSec( game.get_game_time() ),
            tostring( hours )
          )
        end
      end
    end
  end
end


function se_smart_terrain:teleport_to_xyzlg( sobj )
  if not self.xyzlg then return false end
  -- log2(
  --   "[%s]: [%s]: teleport %s to xyzlg: ( %s, %s, %s ), %s, %s",
  --   script_name(), self:name(), sobj:name(), unpack( self.xyzlg )
  -- )
  local x, y, z, lvid, gvid = unpack( self.xyzlg )
  alife():teleport_object( sobj.id, vector():set( x, y, z ), lvid, gvid )
  -- log2(
  --   "[%s]: [%s]: %s teleported to xyzlg",
  --   script_name(), self:name(), sobj:name()
  -- )
  return true
end


function se_smart_terrain:update_xyzlg( from_lvid )
  local level_vertexes = amk_anoms.level_vertexes[ level.name() ]
  if from_lvid >= level_vertexes then
    log2(
      "[%s]: [%s]: unable update xyzlg using lvid = %s: level_vertexes is %s",
      script_name(), self:name(), tostring( from_lvid ), level_vertexes
    )
    return
  end
  local pos, lvid, gvid = dsh.find_random_lvid_in_radius(
    from_lvid, math.random( 10, 200 )
  )
  if pos then
    ASSERT(
      object_level_name( self ) == level_system_name_by_gvid( gvid ),
      "[%s]: %s: wrong gvid %s: level.name() = %s, from_lvid = %s",
      script_name(), self:name(), tostring( gvid ), level.name(),
      tostring( from_lvid )
    )
    self.xyzlg = { pos.x, pos.y, pos.z, lvid, gvid }
  else
    self.xyzlg = nil
  end
  -- log2(
  --   "[%s]: [%s]: update xyzlg to: %s",
  --   script_name(), self:name(),
  --   (
  --     self.xyzlg
  --       and string.format( "( %s, %s, %s ), %s, %s", unpack( self.xyzlg ) )
  --       or "nil"
  --   )
  -- )
  local ini = self:spawn_ini()
  ini.readonly = false
  if self.xyzlg then
    ini:w_string( "dsh", "xyzlg", table.concat( self.xyzlg, "," ) )
  elseif ini:section_exist( "dsh" ) then
    ini:remove_line( "dsh", "xyzlg" )
  end
  self:save_spawn_ini()
end


function on_death( id )
  -- log2( "on_death id=%d", id )
  if alife() then
    local sobj = alife():object( id )
    if sobj and sobj.smart_terrain_id then
      local strn_id       = sobj:smart_terrain_id()
      local free_logic_id = dsh.is_free_logic_mob( sobj )
      if free_logic_id then
        strn_id = free_logic_id
      end
      if strn_id ~= 65535 then
        -- обертка для фикса кривых smart_terrain
        local strn = alife():object( strn_id )
        if strn then
          if strn:clsid() == clsid.smart_terrain then
            local begin_job = (
              strn.gulag.Object_didnt_begin_job[ id ] == false
            )
            strn.gulag:clear_dead( id )
            -- clear_dead() вызовет strn:unregister_npc(), а он
            -- вызовет событие on_empty_smart_terrain, обработчик
            -- которого тоже может заблокировать этот смарт на
            -- время. Поэтому, здесь смарт будет блокироваться
            -- только в том случае, если его еще никто другой не
            -- заблокировал.
            if begin_job then
              strn:try_set_idle_timer( sobj )
            end
          else
            log1(
              "load ~~~ smart_terrain.on_death: Обнаружена привязка к несуществующему smart_terrain: "..sobj:name()..", smart_terrain_id: "..tostring(strn_id)..". Привязка удалена."
            )
            sobj:clear_smart_terrain()
          end
        end
      end
    end
  end
end


--' Удаляет объект из смарттеррейнов.
function unregister_npc( npc )
  local sim = alife()
  if sim then
    local obj           = sim:object( npc.id )
    local strn_id       = obj:smart_terrain_id()
    local free_logic_id = dsh.is_free_logic_mob( obj )
    if free_logic_id then
      strn_id = free_logic_id
    end
    if strn_id ~= 65535 then
      -- обертка для фикса кривых smart_terrain
      local strn = sim:object( strn_id )
      if strn then
        if strn:clsid() == clsid.smart_terrain then
          strn:unregister_npc( obj )
        else
          log1(
            "smart_terrain.unregister_npc: Обнаружена привязка к несуществующему smart_terrain: "..obj:name()..", smart_terrain_id: "..tostring(strn_id)..". Привязка удалена."
          )
          obj:clear_smart_terrain()
        end
      end
    end
  end
end


-- прочитать секцию [smart_terrains]
-- вызывается объектами, которые могут ходить под smart terrain
function read_smart_terrain_conditions( self )
  local ini  = self.ini
  local sect = smart_section
  -- в all.spawn оказалось некоторое кол-во мобов, у которых имеется
  -- секция [smart_terrain], вместо [smart_terrains], т.ч. будем ее
  -- обрабатывать тоже.
  for _, s in ipairs({ smart_section, "smart_terrain" }) do
    if ini:section_exist( s ) then
      sect = s
      break
    end
  end
  local dsh_sect = "dsh.se_stalker." .. self:name() .. ".smart_terrains"
  if sys_ini:section_exist( dsh_sect ) then
    ini  = sys_ini
    sect = dsh_sect
  else
    if ( not ini:section_exist( sect ) ) and ini:section_exist( "logic" ) then
      local cfg = get_string( "logic", "cfg", nil, ini )
      if cfg then
        ini = dsh.cached_ini_file( cfg )
      end
    end
  end
  if ini:section_exist( sect ) then
    local conds, str_conds = {}, {}
    local n = ini:line_count( sect )
    if n > 0 then
      for i = 0, n - 1 do
        local result, field, str = ini:r_line( sect, i, "", "" )
        str = string.gsub( str, "{-aes_arrive_to}", "true" )
        str_conds[ field ] = str
        conds[ field     ] = xr_logic.parse_condlist(
          self, sect, field, str
        )
      end
      return conds, str_conds
    end
  end
  if ini:section_exist( "logic" ) then
    -- опаньки, имеется [logic], но нет [smart_terrains], т.е. нет
    -- никакого запрета на принятие в смарты. И как это понимать, как
    -- это должно работать? Ладно, будем считать, что таким мобам в
    -- смарты нельзя.
    local str_conds = {
      [ "none" ] = "true",
    }
    local conds = {}
    for k, v in pairs( str_conds ) do
      conds[ k ] = xr_logic.parse_condlist( self, sect, k, v )
    end
    return conds, str_conds
  end
end


-- Вывод статистики по всем смартам в симуляции
function stat()
  log1(
    "--------------- Smart terrains statistics START ----------------------"
  )
  local jobs, jobs_in_avail, occupied
  local level_stats = {}
  for level_name, t in pairs( smart_terrains ) do
    jobs, jobs_in_avail, occupied = 0, 0, 0
    for id, strn in pairs( t ) do
      local avail, pop, cap = strn:stat()
      jobs     = jobs     + cap
      occupied = occupied + pop
      if avail then
        jobs_in_avail = jobs_in_avail + cap
      end
    end
    local l = {}
    level_stats[ level_name ] = l
    l.jobs          = jobs
    l.occupied      = occupied
    l.jobs_in_avail = jobs_in_avail
  end
  jobs, jobs_in_avail, occupied = 0, 0, 0
  log1( "" )
  for level_name, l in pairs( level_stats ) do
    log2( "Level %s :", level_name )
    log2( "    Jobs in all smart terrains : %d",       l.jobs )
    log2( "    Jobs in available smart terrains : %d", l.jobs_in_avail )
    log2( "    Occupied jobs : %d",                    l.occupied )
    jobs          = jobs          + l.jobs
    jobs_in_avail = jobs_in_avail + l.jobs_in_avail
    occupied      = occupied      + l.occupied
  end
  log1( "All levels:" )
  log2( "    Jobs in all smart terrains : %d",       jobs )
  log2( "    Jobs in available smart terrains : %d", jobs_in_avail )
  log2( "    Occupied jobs : %d",                    occupied )
  log1(
    "--------------- Smart terrains statistics END ------------------------"
  )
end


function get_smart_terrain_by_name( name )
  local obj = smart_terrains_by_name[ name ]
  if obj then
    return alife():object( obj.id )
  end
end


function iterate_smart_terrains( f )
  for name, _ in pairs( smart_terrains_by_name ) do
    local sobj = get_smart_terrain_by_name( name )
    if sobj then
      f( sobj )
    end
  end
end


function get_monster_classes()
  return monster_classes
end


function se_smart_terrain:get_gulag_type()
  return self.gparams.type
end


function se_smart_terrain:kick_on_update( id )
  if not self.need_kick then self.need_kick = {} end
  self.need_kick[ id ] = true
end


local need_exclusive_update_brains = false

function on_spawn()
  local cnt = 0;
  log2( "[%s]: patch level_groups", script_name() )
  for _, t in ipairs( level_groups_patches ) do
    if t.cond() then
      log2( "[%s]:   apply %s", script_name(), t.label )
      for lname, group in pairs( t.patch ) do
        log2(
          "[%s]:     %s changed: %s -> %s",
          script_name(), lname, tostring( level_groups[ lname ] ), group
        )
        level_groups[ lname ] = group
      end
      cnt = cnt + 1
    end
  end
  if cnt > 0 then
    log2( "[%s]: %s patche(s) applied", script_name(), cnt )
  end
  if need_exclusive_update_brains then
    exclusive_update_brains()
  end
  dsh.timeout(
    smart_terrain_choose_start,
    function()
      dsh.exec_periodic(
        smart_terrain_choose_interval, this.choose_alife_tasks
      )
    end
  )
end


function smart_brain_update( sobj )
  ASSERT(
    (
      sobj:alive()
      and sobj:smart_terrain_id() == 65535
      and sobj:brain():can_choose_alife_tasks()
    ),
    "[%s]: %s is dead or can't choose alife tasks",
    script_name(), sobj:name()
  )
  local conds = sobj.smart_terrain_conditions
  if conds then
    ASSERT(
      conds.none == nil,
      "[%s]: %s has none = %s", script_name(), sobj:name(), conds.none
    )
    for name, condlist in pairs( conds ) do
      if name ~= "any" then
        local strn = alife():object( name )
        if strn and strn:enabled( sobj ) then
          sobj.m_smart_terrain_id = strn.id
          strn:register_npc( sobj )
          ASSERT(
            (
              sobj:smart_terrain_id() == strn.id
              or (
                dsh.is_free_logic_mob( sobj )
                and dsh.is_free_logic_mob( sobj ) == strn.id
              )
            ),
            "[%s]: %s rejected %s (%s): %s",
            script_name(), strn:name(), sobj:name(), sobj.level_name,
            sobj:smart_terrain_id()
          )
          log2(
            "[%s]: %s (%s) registered in %s",
            script_name(), sobj:name(), sobj.level_name, strn:name()
          )
          return
        elseif not strn then
          log2(
            "[%s]: smart terrain %s not found in alife() for %s (%s)",
            script_name(), name, sobj:name(), sobj.level_name
          )
        end
      end
    end
    if
      not (
        conds.any
        and xr_logic.pick_section_from_condlist( db.actor_proxy, sobj, conds.any ) ~= nil
      )
    then
      log2( "[%s]: no smart terrain found for %s", script_name(), sobj:name() )
      return
    end
  end
  sobj:brain():update()
end


function exclusive_update_brains()
  local pt = profile_timer()
  pt:start()
  cnt = 0
  for _, t in pairs({ se_monster.monsters, se_stalker.stalkers }) do
    for id, sobj in pairs( t ) do
      if sobj.need_brain_update then
        ASSERT(
          sobj:alive() and sobj:brain():can_choose_alife_tasks(),
          "[%s]: %s is dead or can't choose alife tasks",
          script_name(), sobj:name()
        )
        local need_brain_update = false
        local conds     = sobj.smart_terrain_conditions
        local str_conds = sobj.smart_terrain_str_conditions
        for k, v in pairs( conds ) do
          if k ~= "any" then
            local strn = alife():object( k )
            if not strn then
              log2(
                "[%s]: smart terrain %s not found in alife() for %s (%s)",
                script_name(), k, sobj:name(), sobj.level_name
              )
            elseif strn:is_gulag_available() then
              local s = xr_logic.pick_section_from_condlist(
                db.actor_proxy, sobj, v
              )
              if s ~= nil then
                log2(
                  "[%s]: register %s (%s) in %s: '%s' = '%s'",
                  script_name(), sobj:name(), sobj.level_name, strn:name(),
                  tostring( str_conds[ k ] ), tostring( s )
                )
                need_brain_update = true
                break
              end
            elseif sobj.smart_terrain_conditions_cnt == 1 then
              -- моб хочет идти исключительно в этот смарт, но смарт
              -- еще закрыт. В этом случае, пусть смарт сам подберет
              -- своих, когда откроется.
              strn.has_waiting_exclusive = true
              sobj.waiting_smart_terrain = strn.id
              sobj:brain():can_choose_alife_tasks( false )
            end
          end
        end
        if need_brain_update then
          log2( "[%s]: update brain %s", script_name(), sobj:name() )
          smart_brain_update( sobj )
          cnt = cnt + 1
        end
        sobj.need_brain_update = false
      end
    end
  end
  pt:stop()
  if cnt > 0 then
    log2(
      "[%s]: %s exclusive brains updated: %s",
      script_name(), cnt, pt:time()
    )
  end
end


local alife_task_t

function choose_alife_tasks()
  if ogse_sleep_mgr.is_sleep_active() then return end
  if alife_task_t then
    log2( "[%s]: choose_alife_tasks() is already running", script_name() )
    return
  end
  local queue, queue2 = {}, {}
  for _, t in pairs({ se_monster.monsters, se_stalker.stalkers }) do
    for id, sobj in pairs( t ) do
      if
        sobj:alive() and sobj:smart_terrain_id() == 65535
        and sobj:brain():can_choose_alife_tasks()
      then
        if sobj.was_in_smart_terrain then
          table.insert( queue,  id )
        else
          table.insert( queue2, id )
        end
      end
    end
  end
  dsh.shuffle( queue  )
  dsh.shuffle( queue2 )
  for _, id in ipairs( queue2 ) do
    table.insert( queue, id )
  end
  if table.getn( queue ) == 0 then
    log2( "[%s]: choose_alife_tasks() nothing to do", script_name() )
    return
  end
  log2(
    "[%s]: choose_alife_tasks() begin: %s in the queue",
    script_name(), table.getn( queue )
  )
  log2(
    "[%s]:   %s was in smart terrains, %s wasn't",
    script_name(), table.getn( queue ) - table.getn( queue2 ),
    table.getn( queue2 )
  )
  local cnt    = 0
  alife_task_t = dsh.exec_periodic(
    smart_terrain_choose_freq,
    function( timer )
      while table.getn( queue ) > 0 do
        local id   = table.remove( queue, 1 )
        local sobj = se_monster.monsters[ id ] or se_stalker.stalkers[ id ]
        if
          sobj and sobj:alive() and sobj:smart_terrain_id() == 65535
          and sobj:brain():can_choose_alife_tasks()
        then
          smart_brain_update( sobj )
          cnt = cnt + 1
          break
        end
      end
      if table.getn( queue ) == 0 then
        timer:stop()
        alife_task_t = nil
        log2(
          "[%s]: choose_alife_tasks() done: %s brains updated",
          script_name(), cnt
        )
      end
    end
  )
end


function fill_exclusives( sobj )
  local conds, str_conds = read_smart_terrain_conditions( sobj )
  if conds then
    sobj.smart_terrain_conditions     = conds
    sobj.smart_terrain_str_conditions = str_conds
    local cnt = 0
    for name, condlist in pairs( conds ) do
      cnt = cnt + 1
      exclusives[ name ] = ( exclusives[ name ] or 0 ) + 1
    end
    sobj.smart_terrain_conditions_cnt = cnt
    if sobj:brain():can_choose_alife_tasks() then
      if cnt == 1 and str_conds.none == "true" then
        sobj:brain():can_choose_alife_tasks( false )
      elseif sobj:smart_terrain_id() == 65535 and sobj:alive() then
        ASSERT(
          conds.none == nil,
          "[%s]: %s has none = %s", script_name(), sobj:name(), str_conds.none
        )
        if cnt > 1 or ( cnt == 1 and not conds.any ) then
          sobj.need_brain_update = true
          need_exclusive_update_brains = true
        end
      end
    end
  elseif sobj.cached_spawner then
    if not sobj:can_be_spawned() then
      -- У моба нет экслюзивного смарта и ему запрещено спауниться. В этом
      -- случае его все равно ни один смарт не примет, так не будем и пытаться.
      -- А вот когда разрешение на спаун сработает, тогда смарты и начнут его
      -- принимать, после ближайшей загрузки. Я не могу представить себе
      -- ситуацию, когда таких мобов нужно прямо вот срочно-срочно принять в
      -- смарт, притом в неважно какой, но срочно.
      sobj:brain():can_choose_alife_tasks( false )
    end
  end
  if not sobj:alive() then
    -- смарты только живых принимают
    sobj:brain():can_choose_alife_tasks( false )
  end
end


-- Смарт только что открылся и нужно найти мобов, которые хотят идти
-- исключительно сюда, принять их или разрешить им поиск смарта, если
-- они еще не готовы.
function se_smart_terrain:register_waiting_exclusives()
  log2(
    "[%s]: %s is available and is looking for exclusives",
    script_name(), self:name()
  )
  for _, t in pairs({ se_monster.monsters, se_stalker.stalkers }) do
    for id, sobj in pairs( t ) do
      if
        sobj.waiting_smart_terrain and sobj.waiting_smart_terrain == self.id
        and sobj:alive()
      then
        sobj.waiting_smart_terrain = nil
        local conds = sobj.smart_terrain_conditions
        ASSERT(
          (
            conds and conds[ self:name() ]
            and sobj.smart_terrain_conditions_cnt == 1
            and sobj:smart_terrain_id() == 65535
            and not sobj:brain():can_choose_alife_tasks()
          ),
          "[%s]: %s is not suitable for %s",
          script_name(), sobj:name(), self:name()
        )
        log2(
          "[%s]: %s has found waiting exclusive %s",
          script_name(), self:name(), sobj:name()
        )
        sobj:brain():can_choose_alife_tasks( true )
        if
          xr_logic.pick_section_from_condlist(
            db.actor_proxy, sobj, conds[ self:name() ]
          )
        then
          log2(
            "[%s]: register %s in %s",
            script_name(), sobj:name(), self:name()
          )
          smart_brain_update( sobj )
        end
      end
    end
  end
end
