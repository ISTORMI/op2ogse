-- -*- mode: lua; coding: windows-1251-dos -*-
-----------------------------------------------------------------------------------
-- Monster binding
-----------------------------------------------------------------------------------

function bind( obj )
  local new_binder = generic_object_binder( obj )
  obj:bind_object( new_binder )
end


class "generic_object_binder" ( object_binder )
function generic_object_binder:__init( obj ) super( obj )
  self.loaded      = false
  self.last_update = 0
  self.am = ogse_signals.get_mgr()
  self.am:call( "on_monster_init", obj, self )
end


function generic_object_binder:reload( section )
  object_binder.reload( self, section )
end


function generic_object_binder:reinit()
  object_binder.reinit( self )

  -- У торговца нет поддержки перемещения
  if self.object:clsid() ~= clsid.script_trader then
    self.object:set_patrol_extrapolate_callback(
      generic_object_binder.extrapolate_callback, self
    )
  end

  db.storage[ self.object:id() ] = {}
  self.st = db.storage[self.object:id() ]
end


function generic_object_binder:net_spawn( sobject )
  if not object_binder.net_spawn( self, sobject ) then
    return false
  end
  ASSERT(
    not db.net_spawning_obj,
    "found net_spawning_obj = %s",
    tostring( db.net_spawning_obj and db.net_spawning_obj:name() or nil )
  )
  db.net_spawning_obj = self.object
  if not self.loaded then
    self:random_visual_zombie()
  end

  db.add_obj(self.object)
  if self.object:alive() then
    db.add_monster( self.object ) -- добавляем в онлайн-живых
    self.object:set_callback(
      callback.patrol_path_in_point, self.waypoint_callback, self
    )
    self.object:set_callback( callback.hit, self.hit_callback, self )
    self.object:set_callback( callback.death, self.death_callback, self )
    self.object:set_callback(
      callback.entity_alive_before_hit, self.before_hit_callback, self
    )
    self.object:set_enemy_callback( self.enemy_callback, self )
  else
    self:set_slowest_scheduler()
  end

  self.object:set_callback( callback.use_object, self.use_callback, self )
  xr_gulag.setup_gulag_and_logic_on_spawn(
    self.object, self.st, sobject, modules.stype_mobile, self.loaded
  )
  amk.on_net_spawn( self.object )

  local particle_param = get_string( self.object:section(), "bones_particles" )
  if particle_param and sys_ini:section_exist( particle_param ) then
    local tmp = amk.parse_ini_section_to_array_new( nil, particle_param )
    for k, v in pairs( tmp ) do
      local t = amk.parse_ini_section_to_array_new( nil, v )
      t.obj   = self.object
      if not t.stop_on_death or self.object:alive() then
        play_particle( self.object, t )
      end
    end
  end

  if self.object:alive() then
    if self.object:is_talk_enabled() then
      self.object:set_tip_text( "character_use" )
    else
      if self.object:section() == "dogfrend" then
        self.object:set_tip_text( "dogfrend_use" )
      else
        self.object:set_tip_text( "" )
      end
    end
  end

  self:subscribe_updaters()
  self.am:call( "on_monster_spawn", self.object, self )
  db.net_spawning_obj = false

  return true
end


function generic_object_binder:subscribe_updaters()
  if self.object:alive() then
    self.updaters = {
      {
        [ "signal" ] = "on_monster_update." .. self.object:id(),
        [ "self"   ] = self,
        [ "fun"    ] = self.check_blowout_and_logic_update,
      },
    }
  else
    self.updaters = {}
  end
  for _, s in ipairs( self.updaters ) do
    self.am:subscribe( s )
  end
end


function generic_object_binder:check_blowout_and_logic_update()
  self.am:reschedule( math.random( 1000, 2000 ) )
  local blowout = amk.load_variable( "blowout", 0 )
  if blowout == 3 and ( not self.control_override ) then
    if not self.object:action() then
      -- Захватываем зверушку
      xr_logic.mob_capture( self.object, true )
      self.control_override = true
    end
    self.am:reschedule( 1000 )
  elseif self.control_override and blowout == 3 then
    if not self.object:action() then
      local snds = { sound.take_damage, sound.panic, sound.idle }
      local snd  = snds[ math.random( table.getn( snds ) ) ]
      action(
        self.object,
        anim( anim.lie_idle, 0 ),
        sound( snd ),
        cond( cond.sound_end )
      )
    end
    self.am:reschedule( 1000 )
  elseif self.control_override and blowout ~= 3 then
    -- отпускаем зверушку
    self.control_override = nil
    xr_logic.mob_release( self.object )
  elseif self.st.active_section ~= nil then
    xr_logic.issue_event(
      self.object, self.st[ self.st.active_scheme ], "update", 0
    )
    self.am:reschedule( 100 )
  end
end


function generic_object_binder:clear_callbacks()
  self.object:set_callback( callback.patrol_path_in_point, nil )
  self.object:set_callback( callback.hit, nil )
  self.object:set_callback( callback.death, nil )
  self.object:set_callback( callback.entity_alive_before_hit, nil )
  if self.object:is_custom_monster() then
    self.object:set_enemy_callback()
  end
end


function generic_object_binder:death_callback( victim, who )
  self:clear_callbacks()
  if not self.object then self.object = victim end
  db.del_monster( self.object ) -- убираем из онлайн-живых

  if db.actor then
    -- добавление опыта за убийство
    xr_statistic.addKillCount( who, self.object )
  end

  if self.st and self.st.mob_death then
    xr_logic.issue_event(
      self.object, self.st.mob_death, "death_callback", victim, who
    )
  end

  if self.st and self.st.active_section then
    xr_logic.issue_event(
      self.object, self.st[self.st.active_scheme], "death_callback", victim,
      who
    )
  end

  smart_terrain.on_death( self.object:id() )

  -- Наносим небольшой импульс вперед.
  local h = hit()
  h.draftsman = self.object
  h.type      = hit.fire_wound
  h.direction = db.actor:position():sub( self.object:position() )
  h:bone( "pelvis" )
  h.power     =  1
  h.impulse   = 10
  self.object:hit( h )

  --AMK UTILS--
  amk.on_death( victim, who )
  --AMK UTILS--

  for _, s in ipairs( self.updaters ) do
    self.am:unsubscribe( s )
  end
  self.updaters = {}
  self:set_slowest_scheduler()

  self.am:call( "on_monster_death", self.object, who )
end


function generic_object_binder:update( delta )
  db.storage[ self.object:id() ].us = 100
  object_binder.update( self, delta )
  db.storage[ self.object:id() ].us =   0

  if not self.first_update then
    self.first_update = true
    self.am:call( "on_monster_first_update", self.object, delta )
  end

  self.am:call( "on_monster_update", self.object, delta )
  self.am:call(
    "on_monster_update." .. self.object:id(), self.object, delta
  )
end


function generic_object_binder:extrapolate_callback()
  if not self.object then return false end
  if self.object:get_script() == false then return false end
  local cur_pt = self.object:get_current_point_index()
  if patrol( self.object:patrol() ):flags( cur_pt ):get() == 0 then
    return true
  end
  return false
end


function generic_object_binder:waypoint_callback( obj, action_type, index )
  if self.st.active_section ~= nil then
    xr_logic.issue_event(
      self.object, self.st[ self.st.active_scheme ], "waypoint_callback",
      obj, action_type, index
    )
  end
end


function generic_object_binder:hit_callback( obj, amount, local_direction, who, bone_index )
  if self.st and self.st.active_section then
    xr_logic.issue_event(
      self.object, self.st[ self.st.active_scheme ], "hit_callback", obj,
      amount, local_direction, who, bone_index
    )
  end
  if self.st and self.st.hit then
    xr_logic.issue_event(
      self.object, self.st.hit, "hit_callback", obj, amount, local_direction,
      who, bone_index
    )
  end

  self.am:call(
    "on_monster_hit", obj, amount, local_direction, who, bone_index
  )
end


function generic_object_binder:net_destroy()
  self:clear_callbacks()
  self.object:set_callback( callback.use_object, nil )
  local st = db.storage[ self.object:id() ]
  if st and st.active_scheme then
    xr_logic.issue_event( self.object, st[ st.active_scheme ], "net_destroy" )
  end
  db.del_obj( self.object )
  db.storage[ self.object:id() ] = nil

  if self.object:alive() then
    db.del_monster( self.object ) -- убираем из онлайн-живых
  end

  for _, s in ipairs( self.updaters ) do
    self.am:unsubscribe( s )
  end
  self.updaters = {}

  self.am:call( "on_monster_net_destroy", self.object, self )
  self.am:cleanup_signal_subs( "on_monster_update." .. self.object:id() )
  object_binder.net_destroy(self)

  -- АМК. Очистка рестрикторов
  if self.object:is_custom_monster() then
    local sobj = alife():object( self.object:id() )
    if sobj then
      alife():remove_in_restrictions( sobj )
    end
  end
end


function generic_object_binder:reload(section)
  object_binder.reload( self, section )
end


function generic_object_binder:net_save_relevant()
  return true
end


function generic_object_binder:save( packet )
  ASSERT(
    not db.saving_obj,
    "found saving_obj = %s",
    tostring( db.saving_obj and db.saving_obj:name() or nil )
  )
  db.saving_obj = self.object
  object_binder.save( self, packet )
  xr_logic.save_obj( self.object, packet )
  if self.object:clsid() == clsid.script_trader then
    trade_manager.save( self.object, packet )
  end
  db.saving_obj = false
end


function generic_object_binder:load( reader )
  self.loaded = true
  object_binder.load( self, reader )
  if reader:r_eof() then
    -- фикс правки Дружка без НИ
    if self.object:section() == "dogfrend" then return end
    remove_zavis.remove_obj( self.object )
  end
  xr_logic.load_obj( self.object, reader )
  if self.object:clsid() == clsid.script_trader then
    trade_manager.load( self.object, reader )
  end
end


-- ОП-2: Добавлен калбек на юзанье монстра, а также для всех монстров
-- подключена схема on_use.
-- Cхема on_use не подключена для класса script_trader (Василий и Сидорович)
-- для обратной совместимости.
function generic_object_binder:use_callback( obj, who )
  if self.object:clsid() == clsid.script_trader then return end
  if self.object:alive() then
    if self.st.active_section then
      xr_logic.issue_event(
        self.object, self.st[ self.st.active_scheme ], "use_callback", obj, who
      )
    end
  end
  self.am:call( "npc_use", self.object, who )
end


function generic_object_binder:random_visual_zombie()
  local visuals = {
    [[monsters\zombi\zombi_1]],
    [[monsters\zombi\zombi_2]],
    [[monsters\zombi\zombi_trup]],
    [[monsters\zombi\zombi_trup_2]],
    [[monsters\zombi\zombi_1_ghost]],
    [[monsters\zombi\zombi_3]],
    [[monsters\zombi\zombi_4_2]],
    [[monsters\zombi\zombi_5]],
    [[monsters\zombi\zombi_6]],
    [[monsters\zombi\zombi_7]],
    [[monsters\zombi\zombi_8]],
    [[monsters\zombi\zombi_9]],
    [[monsters\zombi\zombi_10]],
    [[monsters\zombi\zombi_11]],
    [[monsters\zombi\zombi_12]],
    [[monsters\zombi\zombi_13]],
    [[monsters\zombi\zombi_14]],
    [[monsters\zombi\zombi_15]],
    [[monsters\zombi\zombi_16]],
    [[monsters\zombi\zombi_komar]],
  }
  local section = self.object:section()
  if
    section == "zombie_blow"
    or section == "zombie_beee"
    or section == "zombie_hell"
  then
    local sobj = alife():object( self.object:id() )
    local pk   = get_netpk( sobj, 1 )
    ASSERT( ( pk and pk:isOk() ), "can't read netpacket of %s", sobj:name() )
    local data = pk:get()
    data.visual_name = visuals[ math.random( table.getn( visuals ) ) ]
    pk:set( data )
  end
end


function generic_object_binder:enemy_callback( obj, enemy_st )
  if not obj:alive() then return false end
  local valid, enemy = validate_enemy_object( enemy_st )
  if valid then
    local result = {}
    if enemy:alive() then
      self.am:call( "on_monster_enemy_callback", obj, enemy, result )
    else
      table.insert( result, false )
    end
    for _, v in ipairs( result ) do
      if not v then
        disable_memory_object( obj, enemy )
        return false
      end
    end
  end
  return true
end


function generic_object_binder:before_hit_callback( hit_data )
  if not self.last_hit_data then
    self.last_hit_data = {}
  end
  local who = hit_data.who
  if who and who:is_monster() then
    hit_data.power = hit_data.power * 0.1
  end
  dsh.copy_hit_data( hit_data, self.last_hit_data )
  self.am:call( "on_monster_before_hit", self.object, hit_data )
end


function generic_object_binder:set_slowest_scheduler()
  self.object:configure_scheduler( 100, 1000 )
  self.object:set_slowest_scheduler( true )
end


function play_particle( ... )
  dsh_particles.play_particle( ... )
end
