-- -*- mode: lua; coding: windows-1251-dos -*-

local fly_speed = 1


function attach( sm )
  sm:subscribe({ signal = "on_use", fun = this.on_use })
end


function on_use( obj, sobj )
  local sect = obj:section()
  if
    sect == "arc_art_box_basic"
    or sect == "arc_art_box_8basic"
    or sect == "arc_art_box_1basic"
  then
    show_menu( obj )
    return true
  end
end


local active_menu = false

function show_menu( obj )
  local spwn  = arc_8container_menu( obj )
  active_menu = spwn
  level.start_stop_menu( spwn, true )
end


function possible_inv_change()
  if active_menu then
    active_menu.changed = true
  end
end


function decode_custom_data( custom_data, sect, slots )
  if not slots then slots = get_u32( sect, "container_slots" ) end
  local artefacts = {}
  if custom_data and custom_data ~= "" then
    local cd = parse_names( custom_data )
    ASSERT(
      table.getn( cd ) <= slots * 3,
      "[%s]: unexpected arts: %s > %s", script_name(), table.getn( cd ),
      slots * 3
    )
    for i = 1, slots do
      local t = {}
      local sect = cd[ i ]
      if sect ~= "_" then
        t.section   = sect
        t.condition = tonumber( cd[ slots + i ] )
        local custom_data = cd[ slots * 2 + i ]
        if custom_data ~= "_" then
          t.custom_data = custom_data
        end
      end
      table.insert( artefacts, t )
    end
  end
  return artefacts
end


function encode_custom_data( artefacts, sect, slots )
  if not slots then slots = get_u32( sect, "container_slots" ) end
  local arts = 0
  for _, t in ipairs( artefacts ) do
    if t.section then arts = arts + 1 end
  end
  local cd = {}
  if table.getn( artefacts ) > 0 and arts > 0 then
    for _, k in ipairs({ "section", "condition", "custom_data" }) do
      for i = 1, slots do
        if i > table.getn( artefacts ) then
          table.insert( cd, "_" )
        else
          local t = artefacts[ i ]
          if t.section then
            table.insert( cd, ( t[ k ] or "_" ) )
          else
            table.insert( cd, "_" )
          end
        end
      end
    end
  end
  return table.concat( cd, "," )
end


class "arc_8container_menu" ( dsh_ui.dshCUIScriptWnd )
function arc_8container_menu:__init( obj ) super()
  self.object = obj
  self:read_params()
  self:load_artefacts()
  self:load_inventory()
  self:load_containers()

  self.xml = CScriptXmlInit()
  self.xml:ParseFile( self.xml_name )
  self:DrawBackground()
  self:draw_weight()
  self:draw_artefacts()
  self:draw_inventory()
  self:subscribe_signals()

  self.flying = {}
  self.fly_it = {}
end

function arc_8container_menu:__finalize() end


local radiation_v = get_float( "actor_condition", "radiation_v" )

function arc_8container_menu:read_params()
  local prefix = "arc_ui_8container_menu."
  local sect   = self.object:section()
  self.xml_name = get_string( sect, prefix .. "xml" )
  self.menu_cfg = {}
  for _, k1 in ipairs({ "put", "take" }) do
    local prefix2 = prefix .. k1 .. "."
    local t = {}
    self.menu_cfg[ k1 ] = t
    for _, k2 in ipairs({ "row_size", "space", "x_start", "y_start" }) do
      t[ k2 ] = get_u32( sect, prefix2 .. k2 );
    end
    t.space_x = get_u32( sect, prefix2 .. "space_x", t.space );
    t.space_y = get_u32( sect, prefix2 .. "space_y", t.space );
  end
  self.protection = get_u32( sect, "container_protection", 0 )
  if self.protection > 0 then
    self.protection = ( self.protection + 0.1 ) * radiation_v
  end
  self.slots  = get_u32( sect, "container_slots" )
  self.weight = get_float( sect, "inv_weight" )
end


function arc_8container_menu:load_artefacts()
  local sobj = alife():object( self.object:id() )
  self.artefacts = decode_custom_data(
    sobj.custom_data, sobj:section_name(), self.slots
  )
end


function arc_8container_menu:update_radiation()
  local rad = 0
  if self.protection > 0 then
    for i, t in ipairs( self.artefacts ) do
      if t.section and t.condition > 0 then
        local rrs = get_float( t.section, "radiation_restore_speed", 0 )
        if rrs > self.protection then rad = rad + ( rrs - self.protection ) end
      end
    end
    local iitem = self.object:get_inventory_item()
    ASSERT(
      iitem, "[%s]: %s not an inventory_item", script_name(), self.object:name()
    )
    iitem.radiation_restore_speed = rad
    arc_radiation.register_item( self.object:id(), rad )
  end
  return rad
end


function arc_8container_menu:update_grouping()
  for i, t in ipairs( self.artefacts ) do
    if t.section then
      set_item_always_ungroupable( self.object, true )
      return
    end
  end
  set_item_always_ungroupable( self.object, false )
end


function arc_8container_menu:save_artefacts()
  local sobj = alife():object( self.object:id() )
  sobj.custom_data = encode_custom_data(
    self.artefacts, sobj:section_name(), self.slots
  )
  dsh.set_inv_item_weight( self.object, self.weight + self:draw_weight() )
  self:update_radiation()
  self:update_grouping()
end


function arc_8container_menu:detach_button( s )
  s.button   = nil
  s.progress = nil
  if s.flying then
    for i, t in ipairs( self.flying ) do
      if s == t then
        table.remove( self.flying, i )
        s.flying = nil
        break
      end
    end
    ASSERT(
      s.flying == nil,
      "[%s]: %s not found in self.flying", script_name(), s:WindowName()
    )
  end
  self.scrolled:DetachChild( s )
end


function arc_8container_menu:load_inventory()
  local idx = {}
  if self.inventory then
    for _, t in ipairs( self.inventory ) do
      idx[ t.id ] = t
    end
  end

  self.inventory = {}
  local changed = false
  db.actor:iterate_ruck(
    function( npc, obj )
      if
        alife():object( obj:id() )
        and ( not db.actor:marked_dropped( obj ) )
        and obj:is_artefact() and dsh.is_artefact( obj:section() )
        and dsh_rukzak.can_include_into_actor_items( obj )
      then
        local t = {}
        t.object    = obj
        t.id        = obj:id()
        t.section   = obj:section()
        t.condition = obj:condition()
        local sobj = alife():object( obj:id() )
        if sobj.custom_data and sobj.custom_data ~= "" then
          t.custom_data = sobj.custom_data
        end
        table.insert( self.inventory, t )
        if idx[ obj:id() ] then
          if t.condition < idx[ obj:id() ].condition then
            changed = true
          end
          t.button = idx[ obj:id() ].button
          idx[ obj:id() ] = nil
        else
          changed = true
        end
      end
    end,
    db.actor
  )

  for id, t in pairs( idx ) do
    local s = t.button
    self:detach_button( s )
    changed = true
  end

  table.sort(
    self.inventory,
    function( a, b )
      if a.section == b.section then
        return a.condition > b.condition
      else
        return a.section < b.section
      end
    end
  )

  return changed
end


function arc_8container_menu:load_containers()
  self.containers = {}
  db.actor:iterate_ruck(
    function( npc, obj )
      if
        obj:section() == self.object:section()
        and alife():object( obj:id() )
        and ( not db.actor:marked_dropped( obj ) )
      then
        table.insert( self.containers, obj )
      end
    end,
    db.actor
  )
  for i, obj in ipairs( self.containers ) do
    if obj:id() == self.object:id() then
      if i == table.getn( self.containers ) then
        self.next_n = false
      else
        self.next_n = i + 1
      end
      if i == 1 then
        self.prev_n = false
      else
        self.prev_n = i - 1
      end
      break
    end
  end
end


function arc_8container_menu:DrawBackground()
  self.xml:InitWindow( "main", 0, self )
  self.xml:InitStatic( "background", self )
  self.arts_weight = self.xml:InitStatic( "arts_weight", self )

  local scroll  = self.xml:InitScrollView( "scroll", self )
  self.scrolled = self.xml:InitStatic( "scrolled", scroll )
  self.min_scrolled_height = self.scrolled:GetHeight()
  local art_box = self.xml:InitStatic( "art_box", self.scrolled )

  self.btn_quit = self.xml:InitButton( "btn_quit", art_box )
  self:Register( self.btn_quit, self.btn_quit:WindowName() )
  self:dshAddCallback(
    self.btn_quit:WindowName(), ui_events.BUTTON_CLICKED,
    self.on_quit, self
  )

  self.btn_prev = self.xml:InitButton( "btn_prev", art_box )
  self:Register( self.btn_prev, self.btn_prev:WindowName() )
  self:dshAddCallback(
    self.btn_prev:WindowName(), ui_events.BUTTON_CLICKED,
    self.prev_container, self
  )
  self.btn_prev:Show( self.prev_n and true or false )

  self.btn_next = self.xml:InitButton( "btn_next", art_box )
  self:Register( self.btn_next, self.btn_next:WindowName() )
  self:dshAddCallback(
    self.btn_next:WindowName(), ui_events.BUTTON_CLICKED,
    self.next_container, self
  )
  self.btn_next:Show( self.next_n and true or false )
end


function arc_8container_menu:draw_weight()
  local sum_weight = 0
  for i, t in ipairs( self.artefacts ) do
    if t.section then
      sum_weight = sum_weight + get_float( t.section, "inv_weight" )
    end
  end
  self.arts_weight:SetText(
    string.format( game.translate_string( "ui_art_box_weights" ), sum_weight )
  )
  return sum_weight
end


function arc_8container_menu:make_art_button( t )
  local s = self.xml:InitStatic( "art", self.scrolled )

  local b = self.xml:InitButton( "art_button", s )
  s.button = b
  CIconParams( t.section ):set_shader( b )
  if t.condition > 0 then
    local rad = get_float( t.section, "radiation_restore_speed", 0 )
    if rad > 0 and t.condition > 0 then
      b:SetText( string.format( "+%.0f", rad / radiation_v ) )
    end
  end

  local p = self.xml:InitProgressBar( "condition_progess_bar", s )
  s.progress = p
  p:SetProgressPos( t.condition * 100 )

  return s
end


function arc_8container_menu:get_target_xy( k, pos )
  local m = self.menu_cfg[ k ]
  local x = m.x_start + ( m.space_x * math.fmod( pos - 1, m.row_size ) )
  local y = m.y_start + ( m.space_y * math.floor( ( pos - 1 ) / m.row_size ) )
  return x, y
end


function arc_8container_menu:draw_artefacts()
  for i, t in ipairs( self.artefacts ) do
    if t.section then
      local s    = self:make_art_button( t )
      local x, y = self:get_target_xy( "take", i )
      s:SetWndPos( x, y )
      self:Register( s.button, "art_button_take_" .. i )
      t.button = s
    end
  end
  for i = 1, self.slots do
    self:dshAddCallback(
      "art_button_take_" .. i, ui_events.BUTTON_CLICKED,
      function( wnd ) wnd:take_artefact( i ) end
    )
  end
end


function arc_8container_menu:take_artefact( n )
  local src = self.artefacts[ n ]
  local s   = src.button
  if s.flying then return end

  self.artefacts[ n ] = {}
  self:save_artefacts()

  local wpos = s:GetWndPos()
  self:detach_button( s )

  local sobj = alife():create(
    src.section,
    db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(),
    db.actor:id()
  )
  sobj = alife():object( sobj.id )
  if src.custom_data then
    sobj.custom_data = base64.dec( src.custom_data )
  end
  local iitem = sobj:get_inventory_item()
  iitem.item_condition = src.condition

  self.fly_it[ sobj.id ] = vector():set( wpos.x, wpos.y, 0 )
end


function arc_8container_menu:draw_inventory()
  local scrolled_h = self.min_scrolled_height
  for i, t in ipairs( self.inventory ) do
    local s    = self:make_art_button( t )
    local x, y = self:get_target_xy( "put", i )
    s:SetWndPos( x, y )
    self:Register( s.button, "art_button_put_" .. i )
    self:dshAddCallback(
      s.button:WindowName(), ui_events.BUTTON_CLICKED,
      function( wnd ) wnd:put_artefact( i ) end
    )
    t.button = s
    local max_h = s:GetPosTop() + s:GetHeight()
    if max_h > scrolled_h then scrolled_h = max_h end
  end
  if scrolled_h > self.min_scrolled_height then
    self.scrolled:SetHeight( scrolled_h )
  end
  self.added_callbacks = table.getn( self.inventory )
end


function arc_8container_menu:put_artefact( n )
  local src = self.inventory[ n ]
  if src.button.flying then return end

  local dst, pos
  for i, t in ipairs( self.artefacts ) do
    if not t.section then
      dst = t
      pos = i
      break
    end
  end
  if not dst then
    if table.getn( self.artefacts ) == self.slots then return end
    dst = {}
    table.insert( self.artefacts, dst )
    pos = table.getn( self.artefacts )
  end

  for _, k in ipairs({ "section", "condition", "custom_data" }) do
    dst[ k ] = src[ k ]
  end
  if dst.custom_data then
    dst.custom_data = base64.enc( dst.custom_data )
  end
  self:save_artefacts()

  local wpos = src.button:GetWndPos()
  src.button:Show( false )
  local s    = self:make_art_button( dst )
  local x, y = self:get_target_xy( "take", pos )
  s.flying = {
    progress    = 0.1,
    start_pos   = vector():set( wpos.x, wpos.y, 0 ),
    start_time  = time_global(),
    target_pos  = vector():set( x, y, 0 ),
  }
  table.insert( self.flying, s )
  s:SetWndPos( wpos.x, wpos.y )
  self:Register( s.button, "art_button_take_" .. pos )
  dst.button = s

  ogse.remove_item_from_inventory( src.object )
end


function arc_8container_menu:subscribe_signals()
  self.signals = {
    { signal = "on_drop_before_all", fun = self.on_drop, self = self },
    { signal = "on_take", fun = self.on_take, self = self },
  }
  local sm = ogse_signals.get_mgr()
  for _, s in ipairs( self.signals ) do
    sm:subscribe( s )
  end
end


function arc_8container_menu:unsubscribe_signals()
  local sm = ogse_signals.get_mgr()
  for _, s in ipairs( self.signals ) do
    sm:unsubscribe( s )
  end
  self.signals = nil
end


function arc_8container_menu:on_drop( obj )
  self.changed = true
end


function arc_8container_menu:on_take( obj )
  self.changed = true
end


function arc_8container_menu:reload_inventory()
  if not self:load_inventory() then return end
  local scrolled_h = self.min_scrolled_height
  for i, t in ipairs( self.inventory ) do
    local btn_name = "art_button_put_" .. i
    local s = t.button
    if s then
      s.button:SetWindowName( btn_name )
    else
      s = self:make_art_button( t )
      self:Register( s.button, btn_name )
      t.button = s
    end
    s.progress:SetProgressPos( t.condition * 100 )
    local x, y    = self:get_target_xy( "put", i )
    local fly_pos = self.fly_it[ t.id ]
    if fly_pos then
      s.flying = {
        progress    = 0.1,
        start_pos   = fly_pos,
        start_time  = time_global(),
        target_pos  = vector():set( x, y, 0 ),
      }
      s:SetWndPos( fly_pos.x, fly_pos.y )
      self.fly_it[ t.id ] = nil
      table.insert( self.flying, s )
    elseif s.flying then
      s.flying.target_pos = vector():set( x, y, 0 )
    else
      s:SetWndPos( x, y )
    end
    local max_h = y + s:GetHeight()
    if max_h > scrolled_h then scrolled_h = max_h end
  end
  if scrolled_h > self.min_scrolled_height then
    self.scrolled:SetHeight( scrolled_h )
  end
  if table.getn( self.inventory ) > self.added_callbacks then
    for i = self.added_callbacks + 1, table.getn( self.inventory ) do
      self:dshAddCallback(
        "art_button_put_" .. i, ui_events.BUTTON_CLICKED,
        function( wnd ) wnd:put_artefact( i ) end
      )
    end
    self.added_callbacks = table.getn( self.inventory )
  end
end


function arc_8container_menu:Update()
  CUIScriptWnd.Update( self )
  if self.changed then
    self:reload_inventory()
    self.changed = false
  end
  if table.getn( self.flying ) then
    self:update_flying()
  end
end


function arc_8container_menu:update_flying()
  for _, s in ipairs( self.flying ) do
    local t  = s.flying
    local dt = ( time_global() - t.start_time ) / 1000
    t.progress = t.progress + dt * fly_speed
    if t.progress > 1 then t.progress = 1 end
    local p = vector():sub( t.target_pos, t.start_pos )
    p:mul( t.progress  )
    p:add( t.start_pos )
    s:SetWndPos( math.floor( p.x ), math.floor( p.y ) )
  end
  for i = table.getn( self.flying ), 1, -1 do
    local s = self.flying[ i ]
    if s.flying.progress == 1 then
      table.remove( self.flying, i )
      s.flying = nil
    end
  end
end


function arc_8container_menu:stop_flying()
  for _, s in ipairs( self.flying ) do
    local t = s.flying
    s:SetWndPos( t.target_pos.x, t.target_pos.y )
  end
  self.flying = {}
end


function arc_8container_menu:on_quit()
  self:unsubscribe_signals()
  self:GetHolder():start_stop_menu( self, true )
  self:dsh_unregister_self()
  active_menu = false
end



function arc_8container_menu:OnKeyboard( dik, keyboard_action )
  CUIScriptWnd.OnKeyboard( self, dik, keyboard_action )
  if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
    if dik == DIK_keys.DIK_ESCAPE then
      self:on_quit()
    end
  end
  return true
end


function arc_8container_menu:reload_artefacts()
  self:stop_flying()
  for _, t in ipairs( self.artefacts ) do
    if t.button then
      self:detach_button( t.button )
    end
  end
  self:load_artefacts()
  self:draw_weight()
  for i, t in ipairs( self.artefacts ) do
    if t.section then
      local s = self:make_art_button( t )
      s:SetWndPos( self:get_target_xy( "take", i ) )
      self:Register( s.button, "art_button_take_" .. i )
      t.button = s
    end
  end
end


function arc_8container_menu:next_container()
  self.object = self.containers[ self.next_n ]
  self.prev_n = self.next_n - 1
  if self.next_n == table.getn( self.containers ) then
    self.next_n = false
  else
    self.next_n = self.next_n + 1
  end
  self.btn_prev:Show( true )
  self.btn_next:Show( self.next_n and true or false )
  self:reload_artefacts()
end


function arc_8container_menu:prev_container()
  self.object = self.containers[ self.prev_n ]
  self.next_n = self.prev_n + 1
  if self.prev_n == 1 then
    self.prev_n = false
  else
    self.prev_n = self.prev_n - 1
  end
  self.btn_prev:Show( self.prev_n and true or false )
  self.btn_next:Show( true )
  self:reload_artefacts()
end
